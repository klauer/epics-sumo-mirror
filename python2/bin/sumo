#! /usr/bin/env python
# -*- coding: UTF-8 -*-

# pylint: disable=C0111
#                          Missing docstring
# pylint: disable=C0301
#                          Line too long
# pylint: enable=C0301

# pylint: disable=C0103
#                          Invalid name ... for type module
# pylint: disable=C0322
#                          Operator not preceded by a space

import sys
import os.path
import os
import re
import errno
import shutil
import filecmp
import textwrap
import pydoc

import sumolib.system
import sumolib.lock
import sumolib.JSON
import sumolib.utils
import sumolib.cli
import sumolib.complete
import sumolib.Config
import sumolib.ModuleSpec
import sumolib.Dependencies
import sumolib.Builds
import sumolib.repos

# version of the program:
__version__= "3.0" #VERSION#

assert __version__==sumolib.system.__version__
assert __version__==sumolib.lock.__version__
assert __version__==sumolib.JSON.__version__
assert __version__==sumolib.utils.__version__
assert __version__==sumolib.cli.__version__
assert __version__==sumolib.complete.__version__
assert __version__==sumolib.Config.__version__
assert __version__==sumolib.ModuleSpec.__version__
assert __version__==sumolib.Dependencies.__version__
assert __version__==sumolib.Builds.__version__
assert __version__==sumolib.repos.__version__

KNOWN_MAIN_COMMANDS=set(("build",
                         "config",
                         "db",
                         "help",
                         "lock",
                         "unlock" \
                         ))

KNOWN_CONFIG_COMMANDS=set(("list",
                           "local",
                           "make",
                           "show",
                           "standalone" \
                         ))

KNOWN_DB_COMMANDS=set(("alias-add",
                       "appconvert",
                       "check",
                       "clonemodule",
                       "cloneversion",
                       "convert",
                       "convert-old",
                       "dependency-add",
                       "dependency-delete",
                       "edit",
                       "find",
                       "format",
                       "list",
                       "merge",
                       "modconvert",
                       "releasefilename",
                       "replaceversion",
                       "show",
                       "weight" \
                     ))

KNOWN_BUILD_COMMANDS=set(("delete",
                          "find",
                          "list",
                          "new",
                          "remake",
                          "show",
                          "state",
                          "try",
                          "use" \
                        ))

KNOWN_CONFIG_OPTIONS=set(("#preload",
                          "#opt-preload",
                          "#postload",
                          "#opt-postload",
                          "alias",
                          "buildtag-stem",
                          "dbdir",
                          "dbrepo",
                          "dbrepomode",
                          "editor",
                          "extra",
                          "makeflags",
                          "module",
                          "progress",
                          "readonly",
                          "scandb",
                          "dir-patch",
                          "url-patch",
                          "builddir",
                          "localbuilddir",
                          "verbose" \
                        ))

CONFIG_ENV_EXPAND =set(("dbdir",
                        "dbrepo",
                        "builddir",
                        "localbuilddir" \
                      ))

KNOWN_REPO_MODES=set(( "get", "pull", "push"))

KNOWN_PAGER_MODES=set(("always", "off", "on"))

CONFIG_NAME="sumo.config"
ENV_CONFIG="SUMOCONFIG"
ENV_HELP="SUMOHELP"
BUILDDB="BUILDS.DB"
DB="DEPS.DB"

LOCK_TIMEOUT=4
# timeout for file locking in seconds

catch_exceptions= True
pager_mode= "on"

env_help= os.environ.get(ENV_HELP,"")
if env_help:
    helpoptions= [h_item.strip() for h_item in env_help.split(",")]
    if "nocache" in helpoptions:
        sumolib.complete.CACHING_ENABLED= False
    for pm in KNOWN_PAGER_MODES:
        if "pager:%s" % pm in helpoptions:
            pager_mode= pm

# -----------------------------------------------
# utilities
# -----------------------------------------------

def script_shortname():
    """return the name of this script without a path component."""
    return os.path.basename(sys.argv[0])

rx_exept= re.compile(r'^(Error|error|Err|err)[:, ] *')

def uq(s):
    """remove quotes from a string."""
    if len(s)<2:
        return s
    if s[0]=="'" or s[0]=='"':
        return s[1:-1]
    return s

def errtxt(msg, e):
    """Create an error message from an exception."""
    st= uq(str(e))
    if not msg:
        return st
    e_txt= rx_exept.sub("", st)
    return "%s %s" % (msg, e_txt)

# -----------------------------------------------
# directory utilities and filenames
# -----------------------------------------------

_realpath_cache= {}

def cached_realpath(dir_):
    """returns the realpath but caches the results.
    """
    p= _realpath_cache.get(dir_)
    if p is None:
        p= os.path.realpath(dir_)
        _realpath_cache[dir_]= p
    return p

def makefilename(builddir, build_tag):
    """create a makefile name from a build_tag."""
    return os.path.join(builddir, "Makefile-%s" % build_tag)

def module_dir(builddir, buildtag, modulename, versionname):
    """return the complete path to the module.

    If buildtag is "" or None, return just the base directory for all versions
    and builds of the module.
    """
    if not buildtag:
        return os.path.join(builddir, modulename)
    else:
        return os.path.join(builddir, modulename,
                            "%s+%s" % (versionname, buildtag))

def db_f(path):
    """return the filename of the db file."""
    return os.path.join(path, DB)

def get_builddir(path, path_local):
    """return the build directory that is actually used for new builds."""
    if not path_local:
        return path
    return path_local

def builddb_f(path, path_local):
    """return the filename(s) of the builddb file(s).

    path_local, if given, is the name of the local build directory.

    Return:
    (<build db filename>, <overlay build db filename>)
    """
    if not path_local:
        if not os.path.exists(path):
            raise ValueError("Error, builddir '%s' doesn't exist" % path)
        return (os.path.join(path, BUILDDB), None)
    else:
        if not os.path.exists(path_local):
            raise ValueError("Error, local builddir '%s' doesn't exist" % \
                             path_local)
        return (os.path.join(path_local, BUILDDB),
                os.path.join(path, BUILDDB))

def builddb_localtag(tag):
    """return a "local" marked buildtag."""
    return "local-%s" % tag

def builddb_generate_tag(builddb, buildtag_stem, has_localbuilddir):
    """automatically generate a build tag."""
    if not buildtag_stem:
        buildtag_stem= "AUTO"
    if has_localbuilddir:
        buildtag_stem= builddb_localtag(buildtag_stem)
    return builddb.generate_buildtag(buildtag_stem)

def ensure_dir(dir_, dry_run):
    """create a dir if it doesn't already exist.
    """
    if not dry_run:
        if not os.path.exists(dir_):
            os.makedirs(dir_)

def rm_empty_dir(dirname, verbose, dry_run):
    """remove a directory.

    If the directory is not empty, return without an error message.
    """
    if verbose:
        print "remove dir %s if it is empty" % dirname
    if dry_run:
        return
    try:
        os.rmdir(dirname)
    except OSError, ex:
        if ex.errno == errno.ENOTEMPTY:
            pass

def _assume_dir(dir_, dry_run):
    """ensure that a directory exists."""
    if not dry_run:
        if not os.path.exists(dir_):
            sys.exit("Error, directory 'configure' not found")

# -----------------------------------------------
# load config files
# -----------------------------------------------

def load_config_files(options, disable_loading):
    """Load config files, merge with options and return a Config object."""
    config_name= None
    if not options.no_default_config:
        config_name= CONFIG_NAME
    config= sumolib.Config.ConfigFile.from_optionlist(\
                config_name,
                ENV_CONFIG,
                KNOWN_CONFIG_OPTIONS)

    if disable_loading is None:
        disable_loading= options.disable_loading
    try:
        config.load(options.config, not disable_loading)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while loading config file,",e))
    except IOError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while loading config file,",e))
    config.env_expand(CONFIG_ENV_EXPAND)
    try:
        config.merge_options(options, options.append)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    except TypeError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    return (options, config)

# -----------------------------------------------
# load JSON files
# -----------------------------------------------

def repo_msg(prefix, args):
    """generate a standard commit message."""
    if (not prefix) and (not args):
        # no log message given
        return
    return "%s %s" % (prefix, " ".join(args))

def repo_manager(dbdir, sourcespec_string, mode,
                 verbose, dry_run):
    """create a ManagedRepo object.

    sourcespec_string specifies a repo like:
      darcs <darcs-url>
      hg <mercurial-url>
    """
    if not sourcespec_string:
        return sumolib.repos.ManagedRepo(None,None,None,None,verbose,dry_run)
    if not mode:
        mode= 'get'
    source_spec_obj= \
        sumolib.repos.SourceSpec.from_string_sourcespec(\
                                          sourcespec_string.split())
    mngr= sumolib.repos.ManagedRepo(source_spec_obj,
                                    mode,
                                    dbdir, LOCK_TIMEOUT, verbose, dry_run)
    return mngr

def db_from_json_file(filename, use_lock= True, keep_locked= False):
    """load a db, exits gracefully in case of an error."""
    try:
        db= sumolib.Dependencies.DB.from_json_file(filename,
                                                   use_lock= use_lock,
                                                   keep_lock=keep_locked,
                                                   timeout= LOCK_TIMEOUT)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while loading dependency database,", e))
    except IOError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while loading dependency database,", e))
    return db

def db_from_repo(options, keep_locked= False, changes_check= True,
                 just_get_repo= False):
    """load a db, exits gracefully in case of an error."""
    # pylint: disable=R0913
    #                          Too many arguments
    if just_get_repo:
        repomode= "get"
    else:
        repomode= options.dbrepomode
    mngr= repo_manager(options.dbdir, options.dbrepo, repomode,
                       options.verbose, options.dry_run)
    if mngr.local_changes():
        if not changes_check:
            print "Uncommitted changes found in dependency database file"
        else:
            if not sumolib.utils.ask_yes_no(
                    "Uncommitted changes found in dependency database file,\n"
                    "answer 'y' to record them or 'n' to abort",
                    options.yes):
                sys.exit(0)
            # an empty logmessage here means that the user is asked for one:
            try:
                mngr.commit(options.logmsg)
            except IOError, e:
                # IOError may happen for example with a merge conflict in
                # subversion
                if not catch_exceptions:
                    raise
                sys.exit(errtxt(\
                         "Error while committing dependency database",e))

    try:
        mngr.prepare_read() # executes a "pull" command
    except IOError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while loading dependency database,",e))
    db= db_from_json_file(db_f(options.dbdir), True, keep_locked)
    return (mngr, db)

def db_to_module_cache(options):
    """create a module cache for module cli.
    """
    (_, db)= db_from_repo(options,
                          keep_locked= False, changes_check= False,
                          just_get_repo= True)
    return db

def db_to_repo(options, mngr, db, command, arguments):
    """save a db and use the repo mngr."""
    # pylint: disable=R0913
    #                          Too many arguments
    try:
        db.json_save(db_f(options.dbdir), options.verbose, options.dry_run)
    except IOError, e:
        # IOError may happen when the file cannot be locked
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while saving dependency database",e))
    if mngr:
        if options.logmsg:
            msg= options.logmsg
        else:
            msg= repo_msg(command, arguments)
    try:
        mngr.finish_write(msg)
    except IOError, e:
        # IOError may happen for example with a merge conflict in subversion
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while saving dependency database",e))

def builddb_from_json_file(path, path_local, keep_locked= False,
                           must_exist= True):
    """load a builddb, exits gracefully in case of an error.

    Note: this function only gets the path(s) where the build db file can be
    found, not the filename itself.

    If local_path is given, a *local* build db is created that is merged with
    the build db from <path>.
    """
    # pylint: disable=R0912
    #                          Too many branches

    try:
        (file_, overlay_file)= builddb_f(path, path_local)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    if not os.path.exists(file_):
        if must_exist:
            sys.exit("Error build database '%s' doesn't exist" % \
                     file_)
        # just create an empty object:
        builddb= sumolib.Builds.DB_overlay(use_lock= True,
                                           lock_timeout= LOCK_TIMEOUT)
        # set default filename in the object (JSON.Container method):
        builddb.filename(file_)
    else:
        try:
            builddb= sumolib.Builds.DB_overlay.from_json_file(\
                                    file_,
                                    use_lock= True,
                                    keep_lock= keep_locked,
                                    timeout= LOCK_TIMEOUT)
        except ValueError, e:
            if not catch_exceptions:
                raise
            sys.exit(errtxt("Error while loading build database,",e))
        except IOError, e:
            if not catch_exceptions:
                raise
            sys.exit(errtxt("Error while loading build database,",e))
    if not overlay_file:
        return builddb
    try:
        builddb.overlay(overlay_file)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while loading overlay build database,",e))
    except IOError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while loading overlay build database,",e))
    return builddb

def assert_build_tag(builddb, buildtag):
    """check if the tag exists in builddb.

    does sys.exit on error.
    """
    if not builddb.has_build_tag(buildtag):
        sys.exit("error: buildtag '%s' not found" % buildtag)

def builddb_to_module_cache(options):
    """create a module cache for module cli.
    """
    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= False,
                                    must_exist= False)
    return builddb


def init_buildcache(scandb_name, builddb, db):
    """load a builddb, exits gracefully in case of an error."""
    if not scandb_name:
        buildcache= sumolib.Builds.BuildCache(lock_timeout= LOCK_TIMEOUT)
    else:
        try:
            buildcache= sumolib.Builds.BuildCache.from_json_file(scandb_name,
                                                                 False,
                                                                 LOCK_TIMEOUT)
        except ValueError, e:
            sys.exit(errtxt("Error while loading build database,",e))
            if not catch_exceptions:
                raise
        except IOError, e:
            if not catch_exceptions:
                raise
            sys.exit(errtxt("Error while loading build database,",e))
    buildcache.update_from_builddb(builddb, db)
    return buildcache

# -----------------------------------------------
# aliases
# -----------------------------------------------

def scan_aliases(aliases):
    """scan aliases given on the command line."""
    d= {}
    if not aliases:
        return d
    for a in aliases:
        (from_, to)= a.split(":")
        d[from_]= to
    return d

def alias(alias_dict, modulename):
    """return a module alias."""
    n= alias_dict.get(modulename)
    if n is None:
        return modulename
    return n

# -----------------------------------------------
# error messages
# -----------------------------------------------

def errmsg(msg):
    """print something on stderr."""
    sys.stdout.flush()
    sys.stderr.write(msg+"\n")
    sys.stderr.flush()

tracemsg= errmsg
notemsg= errmsg

# -----------------------------------------------
# module utilities
# -----------------------------------------------

def dump_modules(modulespecs):
    """dump module specs.
    """
    for modulespec in modulespecs:
        print modulespec.to_string()

# -----------------------------------------------
# dependency handling
# -----------------------------------------------

def gather_dependencies(dist_dict, db, modulename, versionname,
                        gathered_deps):
    """recursively gather all dependencies of a module.

    For dependencies, do only take moduleversions that are in dist_dict.

    Returns a dict mapping modulenames to versionnames

    called by builddb_match, command "new"
    """
    if gathered_deps is None:
        gathered_deps= {}
    for dep_name in db.iter_dependencies(modulename, versionname):
        dep_version= dist_dict[dep_name]
        gathered_deps[dep_name]= dep_version
        gathered_deps= gather_dependencies(dist_dict, db, dep_name,
                                           dep_version, gathered_deps)
    return gathered_deps

def _add_dependencies(module_dict, db, build_module_dict,
                      modulename, versionname):
    """recursively add missing dependencies.

    called by get_dependencies, command "use"
    """
    try:
        db.assert_module(modulename, versionname)
    except KeyError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error in dependency database", e))
    for dep in db.iter_dependencies(modulename, versionname):
        if module_dict.has_key(dep):
            continue
        version_present= build_module_dict[dep]
        module_dict[dep]= version_present
        _add_dependencies(module_dict, db, build_module_dict,
                          dep, version_present)

def get_dependencies(module_dict, db, builddb, buildtag):
    """recursively complete the module_dict for missing dependencies.

    called by apprelease, command "use"
    """
    build_module_dict= builddb.modules(buildtag)
    modules= module_dict.items()
    for modulename, versionname in modules:
        _add_dependencies(module_dict, db,
                          build_module_dict, modulename, versionname)

def builddb_match(dist_dict, db, builddb, modulename, versionname):
    """try to find matching deps in builddb.

    called by add_modules, command "new"
    """
    deps= gather_dependencies(dist_dict, db, modulename, versionname, None)
    # now deps is a dict mapping modulenames to versionnames that contains all
    # direct and indirect dependencies of modulename:versionname that was
    # given to this function.
    for build_tag in builddb.iter_builds():
        # try to find modules that were already built, ignore builds that are
        # not marked "stable" or testing.
        # This also means that builds marked "disabled" are ignored.
        if not builddb.is_testing_or_stable(build_tag):
            continue
        if not builddb.has_module(build_tag, modulename):
            continue
        if builddb.module_link(build_tag, modulename):
            # if this build has only a link of the module, skip it
            continue
        modules= builddb.modules(build_tag)
        if modules[modulename]!=versionname:
            # version doesn't match
            continue

        # from here: check if all dependencies match:
        match= True
        for dep_name, dep_ver in deps.items():
            other= modules.get(dep_name)
            if dep_ver!= other:
                match= False
                break
        if match:
            return build_tag
    return

# -----------------------------------------------
# file generation
# -----------------------------------------------

def gen_RELEASE(db, builddb, buildtag,
                dist_dict,
                modulename, versionname,
                module_directory,
                extra_lines,
                verbose, dry_run):
    """generate a RELEASE file.

    Note: the SUPPORT path is the directory of the builddb file!

    dist_dict: a dictionary mapping modulename-->versionname that is
        with respect to dependencies a complete set of modules.

    called by create_module, command "new"
    """
    # pylint: disable=R0913
    #                          Too many arguments
    # pylint: disable=R0914
    #                          Too many local variables

    filename= os.path.join(module_directory,
                           db.get_releasefile(modulename, versionname))
    deps= []

    for dep_name in db.iter_dependencies(modulename, versionname):
        dep_versionname= dist_dict[dep_name]
        deps.append((dep_name, dep_versionname))

    deps= db.sortby_weight(db.sortby_dependency(sorted(deps), True))

    if not deps:
        # if sumo doesn't know of any dependencies, don't touch
        # configure/RELEASE.
        return

    if verbose:
        print "creating %s" % filename
    fh= sumolib.utils.file_w_open(filename, verbose, dry_run)

    sumolib.utils.file_write(fh, "# generated by sumo for build %s\n\n" % \
                             buildtag,
                             verbose, dry_run)

    for (dep_name, dep_versionname) in deps:
        name_here= db.get_alias(modulename, versionname, dep_name)
        buildtag_here= builddb.module_link(buildtag, dep_name)
        if buildtag_here is None:
            buildtag_here= buildtag
        # We have to make a "realpath" here. The old sumo version before
        # revision a5da15aeda71 worked this way. If we would not, some
        # checkRelease.pl calls in some support modules will fail since the
        # path and the canonical "realpath" don't seem to be the same.
        b_dir= cached_realpath(builddb.dirname_from_tag(buildtag_here))
        path= module_dir(b_dir, buildtag_here, dep_name, dep_versionname)
        sumolib.utils.file_write(fh, "%s=%s\n" % (name_here,path),
                                 verbose, dry_run)
    for l in extra_lines:
        sumolib.utils.file_write(fh, "%s\n" % l.rstrip(), verbose, dry_run)
    if not dry_run:
        fh.close()

def create_makefile(dist_dict, db, builddb,
                    build_tag,
                    verbose, dry_run):
    """generate a makefile.

    dist_dict: a dictionary mapping modulename-->versionname that is
        with respect to dependencies a complete set of modules.

    called by create_modules, command "new"
    """
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0913
    #                          Too many arguments
    def has_makefile(path):
        """checks if there is a makefile in path."""
        fn= os.path.join(path,"Makefile")
        if os.path.exists(fn):
            return True
        fn= os.path.join(path,"makefile")
        if os.path.exists(fn):
            return True
        return False
    paths= {}
    builddir= builddb.dirname()
    for modulename, versionname in builddb.iter_modules(build_tag):
        if not builddb.module_link(build_tag, modulename):
            if not has_makefile(module_dir(builddir, build_tag,
                                           modulename, versionname)):
                continue
            # create relative directories in makefiles:
            paths[(modulename, versionname)]= module_dir("", build_tag,
                                                         modulename,
                                                         versionname)
    filename= makefilename(builddir, build_tag)
    module_dirs= sorted(paths.values())
    stamps= [os.path.join(p,"stamp") for p in module_dirs]
    fh= sumolib.utils.file_w_open(filename, verbose, dry_run)
    sumolib.utils.file_write(fh, "all: %s\n\n" % (" ".join(stamps)),
                             verbose, dry_run)

    for target in ("clean", "distclean"):
        sumolib.utils.file_write(fh, "%s:\n" % target, verbose, dry_run)
        for d in module_dirs:
            sumolib.utils.file_write(fh, "\t-$(MAKE) -C %s %s\n" % \
                                         (d, target),
                                     verbose, dry_run)
        for f in stamps:
            sumolib.utils.file_write(fh, "\trm -f %s\n" % f, verbose, dry_run)
        sumolib.utils.file_write(fh, "\n", verbose, dry_run)

    for spec in sorted(paths.keys()):
        path= paths[spec]
        (modulename, versionname)= spec
        own_stamp= os.path.join(path, "stamp")
        dep_stamps= []
        for dep_name in db.iter_dependencies(modulename, versionname):
            if builddb.module_link(build_tag, dep_name):
                continue
            dep_version= dist_dict[dep_name]
            # do no handle dependencies that are not in the paths
            # dictionary:
            if not paths.has_key((dep_name, dep_version)):
                continue
            # use relative paths for dependencies:
            dep_path= module_dir("", build_tag, dep_name, dep_version)
            dep_stamps.append(os.path.join(dep_path,"stamp"))

        dep_stamps.sort()
        if dep_stamps:
            sumolib.utils.file_write(fh,\
                        "\n%s: %s\n" % (own_stamp, " ".join(dep_stamps)),\
                        verbose, dry_run)
    sumolib.utils.file_write(fh, "\n%/stamp:\n", verbose, dry_run)
    sumolib.utils.file_write(fh, "\t$(MAKE) -C $(@D)\n", verbose, dry_run)
    sumolib.utils.file_write(fh, "\ttouch $@\n", verbose, dry_run)
    if not dry_run:
        fh.close()

# -----------------------------------------------
# module creation/deletion
# -----------------------------------------------

def create_source(db, modulename, versionname,
                  destdir, verbose, dry_run):
    """create directory by given source spec.
    """
    # pylint: disable=R0913
    #                          Too many arguments
    sourcespec= sumolib.repos.SourceSpec(db.module_source_dict(modulename,
                                                               versionname))
    try:
        sumolib.repos.checkout(sourcespec,
                               destdir,
                               LOCK_TIMEOUT,
                               verbose, dry_run)
    except IOError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error, checkout failed:", e))

def delete_module(builddir, build_tag, modulename, versionname,
                  must_exist,
                  verbose, dry_run):
    """delete a single module."""
    # pylint: disable=R0913
    #                          Too many arguments
    dirname= module_dir(builddir, build_tag, modulename, versionname)
    if verbose:
        print "removing %s" % dirname
    if not dry_run:
        if os.path.exists(dirname):
            shutil.rmtree(dirname)
        else:
            if must_exist:
                errmsg(("Warning, directory '%s' cannot be deleted, "
                        "it does not exist") % dirname)
        # remove the parent directory if it is empty:
    rm_empty_dir(modulename, verbose, dry_run)

def create_module(db, builddb, build_tag,
                  dist_dict,
                  modulename, versionname,
                  extra_defs,
                  verbose, dry_run):
    """check out a module.

    returns the build_tag that was used. If the module was found in another
    build, return that built-tag.

    dist_dict: a dictionary mapping modulename-->versionname that is
        with respect to dependencies a complete set of modules.

    called by create_modules, command "new"
    """
    # pylint: disable=R0913
    #                          Too many arguments
    basedir= module_dir(builddb.dirname(), "", modulename, "")
    ensure_dir(basedir, dry_run) # creates basedir if it doesn't exist
    dirname= module_dir(builddb.dirname(), build_tag, modulename, versionname)
    if os.path.exists(dirname):
        raise ValueError("directory %s already exists" % dirname)

    create_source(db, modulename, versionname, dirname, verbose, dry_run)
    gen_RELEASE(db, builddb, build_tag,
                dist_dict,
                modulename, versionname,
                dirname,
                extra_defs,
                verbose, dry_run)

# -----------------------------------------------
# builddb utilities
# -----------------------------------------------

_builddb= [None]
def mspecs_from_build(options):
    """generate a function to return module specs from a build."""
    def mspecs(buildtag):
        """return module specs for a buildtag."""
        if _builddb[0] is None:
            if not options.builddir:
                raise AssertionError("--builddir is needed for modulespecs")
            _builddb[0]= builddb_from_json_file(options.builddir,
                                                options.localbuilddir,
                                                keep_locked= False,
                                                must_exist= False)
        return _builddb[0].module_specs(buildtag)
    return mspecs

def add_modules(dist_dict, db, builddb, build_tag):
    """add modules to the builddb object.

    This function looks for compatible modules in all already existing builds.
    If possible, modules of existing builds are used.

    All modules specified by dist_dict are added with tag <build_tag> to the
    builddb.

    called by create_modules, command "new"
    """
    for modulename in sorted(dist_dict.keys()):
        versionname= dist_dict[modulename]

        # try to find a build that already has the module and where all it's
        # dependencies are also present with the same version as in dist_dict:
        compatible_build= builddb_match(dist_dict, db, builddb, modulename,
                                        versionname)
        if compatible_build is None:
            # no existing build of the module was found, we have to build the
            # module ourselbves:
            build_tag_used= build_tag
        else:
            # a compatible existing build of the module was found:
            build_tag_used= compatible_build

        builddb.add_module(build_tag, build_tag_used, modulename, versionname)

# -----------------------------------------------
# further db functions
# -----------------------------------------------

def create_app_data(deps, repoinfo, groups):
    """create configuration data for an app."""
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    keys= deps.keys()
    if len(keys)!=1:
        sys.exit("error: \"dependencies\" map must have exactly one key")

    modulespecs= []
    aliases    = []

    app_path= keys[0]
    specs_by_path= {}

    for module_name, groupdata in groups.items():
        keys= groupdata.keys()
        if len(keys)!=1:
            sys.exit("error: groupdata \"%s\" must have exactly one key" % \
                     module_name)
        root_path= keys[0]
        values= groupdata[root_path]
        if len(values)!=1:
            sys.exit("error: groudata \"%s\" must have exactly one "
                     "subdir" % module_name)
        subdir= values[0]
        versionedmodule_path= os.path.join(root_path, subdir)
        try:
            r_dict= repoinfo.get(versionedmodule_path)
        except KeyError, _:
            # shouldn't happen, but we just print a warning in this
            # case:
            errmsg("no source data: %s" % versionedmodule_path)
            continue

        sourcespec_obj= sumolib.repos.SourceSpec(r_dict)
        if sourcespec_obj.sourcetype()=="path":
            versionname= "PATH-%s" % subdir
        elif sourcespec_obj.sourcetype()=="tar":
            versionname= "TAR-%s" % subdir
        elif sourcespec_obj.is_repo():
            tag= sourcespec_obj.tag()
            if tag is None:
                versionname= "TAGLESS-%s" % subdir
            else:
                versionname= tag
        else:
            raise AssertionError("unsupported sourcetype: %s" % \
                                 sourcespec_obj.sourcetype())
        specs_by_path[versionedmodule_path]= (module_name,versionname)

    for (aliasname, path) in deps[app_path].items():
        (module_name,versionname)= specs_by_path[path]
        modulespecs.append("%s:%s" % (module_name,versionname))
        if aliasname!=module_name:
            aliases.append("%s:%s" % (module_name, aliasname))
    aliases.sort()
    modulespecs.sort()

    return {"alias": aliases, "module": modulespecs}


def create_database(deps, repoinfo, groups, dir_patches, url_patches):
    """join the information of the three sources.
    """
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0915
    #                          Too many statements
    # pylint: disable=R0913
    #                          Too many arguments
    dir_patcher= sumolib.utils.RegexpPatcher()
    url_patcher= sumolib.utils.RegexpPatcher()
    if url_patches:
        for p in url_patches:
            # pylint: disable=W0123
            #                          Use of eval
            url_patcher.add(eval(p))
    if dir_patches:
        for p in dir_patches:
            # pylint: disable=W0123
            #                          Use of eval
            dir_patcher.add(eval(p))
    _path2namevname= {}
    _namevname2path= {}
    db= sumolib.Dependencies.DB(lock_timeout= LOCK_TIMEOUT)
    # we first create the map from modulenames to versiondata. In this loop we
    # populate the versiondata only with the source specification. We also
    # create two maps:
    #    _path2namevname: maps a diretory path to (module_name, versionname)
    #    _namevname2path: maps (module_name,versionname) to a diretory path
    for module_name, groupdata in groups.items():
        # the root directory of all the versions:
        for root_path, subdirs in groupdata.items():
            for subdir in sorted(subdirs):
                # iterate over all versions from <groups>:
                # reconstruct the original directory path:
                versionedmodule_path= os.path.join(root_path, subdir)
                # get the repository data:
                try:
                    r_dict= repoinfo.get(versionedmodule_path)
                except KeyError, _:
                    # shouldn't happen, but we just print a warning in this
                    # case:
                    errmsg("no source data: %s" % versionedmodule_path)
                    continue

                src_sourcespec= sumolib.repos.SourceSpec(r_dict)
                if src_sourcespec.sourcetype()=="path":
                    # the source is a directory path, not a repository. We
                    # generate the unique versionname:
                    if subdir.startswith("PATH-"):
                        # Try to handle a subdir that was created by this set
                        # of tools. Such a subdir may already be named
                        # "PATH-<name>+<treetag>". We want to take <name> as
                        # versionname in this case:
                        versionname= sumolib.utils.split_treetag(subdir)[0]
                    else:
                        versionname= "PATH-%s" % subdir
                    # repodata is just the path in this case:
                    src_sourcespec.path(dir_patcher.apply(\
                                            src_sourcespec.path()))
                elif src_sourcespec.sourcetype()=="tar":
                    # the source is a tar file, not a repository. We
                    # generate the unique versionname:
                    if subdir.startswith("TAR-"):
                        # Try to handle a subdir that was created by this set
                        # of tools. Such a subdir may already be named
                        # "TAR-<name>+<treetag>". We want to take <name> as
                        # versionname in this case:
                        versionname= sumolib.utils.split_treetag(subdir)[0]
                    else:
                        versionname= "TAR-%s" % subdir
                    # we apply not the dir_patched to the path of the tar file
                    # here.
                elif src_sourcespec.is_repo():
                    tag= src_sourcespec.tag()

                    if tag is None:
                        # the source is a repository but has no tag. We
                        # generate a unique versionname:
                        if subdir.startswith("TAGLESS-"):
                            # Try to handle a subdir that was created by this
                            # set of tools. Such a subdir may already be named
                            # "PATH-<name>+<treetag>". We want to take <name>
                            # as versionname in this case:
                            versionname= sumolib.utils.split_treetag(subdir)[0]
                        else:
                            versionname= "TAGLESS-%s" % subdir
                        # patch URL to <versionedmodule_path>. Since we do not
                        # know in what state the working copy repository is, we
                        # have to take this as a source instead of the central
                        # repository:
                    else:
                        # the source is a darcs repository with a tag. We use
                        # the tag as unique versionname:
                        versionname= tag
                    src_sourcespec.url(url_patcher.apply(\
                                           src_sourcespec.url()))
                else:
                    raise AssertionError("unsupported sourcetype: %s" % \
                                         src_sourcespec.sourcetype())

                db.set_source_(module_name, versionname, src_sourcespec)

                _path2namevname[versionedmodule_path]= \
                        (module_name,versionname)
                # when we assume that a versionedmodule_path may contain a
                # buildtag, there may be several versionedmodule_paths for a
                # pair of (module_name, versionname).
                _paths= _namevname2path.setdefault(\
                                    (module_name, versionname),[])
                _paths.append(versionedmodule_path)

    #sumolib.JSON.dump(_path2namevname)
    #sys.exit(0)

    buildcache= sumolib.Builds.BuildCache(lock_timeout= LOCK_TIMEOUT)

    # here we populate the versiondata with the dependency specifications:
    for modulename in db.iter_modulenames():
        # loop on stable, testing and unstable versions:
        for versionname in db.iter_versions(modulename):
            versionedmodule_paths= _namevname2path[(modulename, versionname)]

            for versionedmodule_path in versionedmodule_paths:
                _deps= deps.get(versionedmodule_path)
                if _deps is None:
                    errmsg("no dependency info for path %s" % \
                           versionedmodule_path)
                    continue
                for dep_alias, dep_path in _deps.items():
                    try:
                        (_dep_name, _dep_version)= _path2namevname[dep_path]
                    except KeyError, _:
                        if not catch_exceptions:
                            raise
                        sys.exit(("at module %s version %s "+ \
                                  "path %s: "+ \
                                  "missing data for "+ \
                                  "dependency \"%s\"") % \
                                  (modulename, versionname,
                                   versionedmodule_path,
                                   dep_path))
                    if _dep_name != dep_alias:
                        try:
                            db.add_alias(modulename, versionname,
                                         dep_alias, _dep_name)
                        except ValueError, e:
                            errmsg("alias error in module %s: %s" % \
                                   (modulename, str(e)))
                    db.add_dependency(modulename, versionname,
                                      _dep_name)
                    buildcache.add_dependency(modulename, versionname,
                                              _dep_name, _dep_version,
                                              "scanned")
    return (buildcache,db)

def set_weight(db, weight, modulespecs, trace):
    """set the weight for one or more modules."""
    for modulespec in modulespecs:
        modulename= modulespec.modulename
        if trace:
            tracemsg("%s\n" % modulespec.to_string())

        # scan stable, testing and unstable versions:
        for version in db.iter_versions(modulename):
            if trace:
                tracemsg("test %s:%s\n" % (modulename,version))
            if not modulespec.test(version):
                continue
            if trace:
                tracemsg("set weight %d on %s:%s\n" % \
                                 (weight,modulename,version))
            db.weight(modulename, version, weight)

# -----------------------------------------------
# further builddb functions
# -----------------------------------------------

def delete_modules(builddb, build_tag, verbose, dry_run):
    """delete modules of a build.
    """
    dependends= builddb.linked_builds(build_tag)
    if dependends:
        raise ValueError("Error, the following builds dependend on "
                         "build %s:\n%s" % \
                         (build_tag," ".join(sorted(dependends))))
    must_exist= not builddb.is_incomplete(build_tag)
    for modulename, versionname in builddb.iter_modules(build_tag):
        if builddb.module_link(build_tag, modulename):
            continue
        delete_module(builddb.dirname(), build_tag, modulename, versionname,
                      must_exist, verbose, dry_run)

    makefile= makefilename(builddb.dirname(), build_tag)
    if not os.path.exists(makefile):
        if must_exist:
            errmsg(("Warning, makefile '%s' cannot be deleted, "
                    "it does not exist") % makefile)
    else:
        os.remove(makefilename(builddb.dirname(), build_tag))
    builddb.delete(build_tag)

def create_modules(dist_dict, db, builddb, builddir, build_tag,
                   extra_lines,
                   no_checkout,
                   verbose, dry_run):
    """create all modules.

    dist_dict: a dictionary mapping modulename-->versionname that is
        with respect to dependencies a complete set of modules.

    called by process, command "new"
    """
    # pylint: disable=R0913
    #                          Too many arguments
    module_list  = []

    if builddb.is_fully_linked(build_tag):
        # the new build would contain only links, this is maybe not wanted.
        notemsg("Note: The generated build '%s' consists only of "
                "links.\n" % build_tag)

    for modulename in sorted(dist_dict.keys()):
        versionname= builddb.module_version(build_tag, modulename)
        # do not re-create modules that are links:
        if builddb.module_link(build_tag, modulename):
            continue
        # module_list contains only the modules that are NOT links:
        module_list.append({"modulename" : modulename,
                            "versionname": versionname})

    if not dry_run and not no_checkout:
        ensure_dir(builddir, dry_run)
    if no_checkout:
        return
    for module_dict in module_list:
        create_module(db, builddb, build_tag,
                      dist_dict,
                      module_dict["modulename"],
                      module_dict["versionname"],
                      extra_lines,
                      verbose, dry_run)

def simple_call_make(builddir, makefile, target, makeflags, verbose, dry_run):
    """simple make call."""
    # pylint: disable=R0913
    #                          Too many arguments
    cmd="make %s -C %s -f %s %s" % (" ".join(makeflags),
                                    builddir,
                                    makefile, target)
    try:
        # tracemsg("CALLING MAKE: %s\n" % cmd)
        sumolib.system.system(cmd, False, False, verbose, dry_run)
    except IOError, e:
        if not catch_exceptions:
            raise
        sys.exit("Error: make failed, %s" % str(e))


def call_make(buildtag, options):
    """call "make", then mark the build "testing"."""
    # pylint: disable=R0913
    #                          Too many arguments
    builddir= get_builddir(options.builddir, options.localbuilddir)
    simple_call_make(builddir,
                     makefilename(builddir, buildtag),
                     "all",
                     options.makeflags if options.makeflags else [],
                     options.verbose, options.dry_run)

    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= not options.dry_run)
    builddb.change_state(buildtag, "testing")
    builddb.json_save(None, options.verbose, options.dry_run)
    # ^^^ does also unlock the file

def fullapprelease(build_tag, builddb, db, modules,
                   aliases, extra_lines):
    """create entries for an release file.
    """
    # pylint: disable=R0913
    #                          Too many arguments
    # pylint: disable=R0914
    #                          Too many local variables
    lines= ["# generated by sumo using build %s:\n" % build_tag]
    if modules is None:
        modules= builddb.modules(build_tag).keys()

    directories= {}
    mods= []
    for modulename in modules:
        tag= builddb.module_link(build_tag, modulename)
        if tag is None:
            tag= build_tag
        version= builddb.module_version(tag, modulename)
        b_dir= cached_realpath(builddb.dirname_from_tag(tag))
        directories[(modulename, version)]= \
                    module_dir(b_dir, tag, modulename, version)
        mods.append((modulename, version))

    mods= db.sortby_weight(db.sortby_dependency(sorted(mods), True))
    for (modulename, version) in mods:
        lines.append("%s=%s\n" % \
                (alias(aliases, modulename),
                 directories[(modulename, version)]
                ))
    for l in extra_lines:
        lines.append("%s\n" % l)
    return lines

def apprelease(build_tag, modulespec_complete, modulespecs,
               builddb, db,
               aliases, extra_lines):
    """create entries for an release file.

    used in command "use".
    """
    # pylint: disable=R0913
    #                          Too many arguments
    # pylint: disable=R0914
    #                          Too many local variables
    for modulespec in modulespecs:
        modulename= modulespec.modulename
        if build_tag is None:
            # unspecifed build_tag, all versions must be *exactly specified*:
            if not modulespec.is_exact_spec():
                sys.exit("modulespec '%s' is not an exactly "
                         "specified version" % modulespec.to_string())

    if build_tag is None:
        # must look for a matching build:
        new_builddb= builddb.filter_by_modulespecs(modulespecs)
        if new_builddb.is_empty():
            sys.exit("no build found that matches modulespecs")
        # take only builds that are "testing" or "stable":
        tags= [b for b in new_builddb.iter_builds() \
                 if builddb.is_testing_or_stable(b)]
        if not tags:
            sys.exit("no build with state 'stable' or 'testing' found that "
                     "matches modulespecs")
        if len(tags)>1:
            # more than one build match:
            if not modulespec_complete:
                tag_str= " ".join(sorted(tags))
                sys.exit(("Your module specification is incomplete and "
                          "more than one build matches your specification. "
                          "Select one of the following builds and specify "
                          "it with option '-t': \n%s") % tag_str)
        build_tag= sorted(tags)[0]
        notemsg("using build %s\n" % build_tag)


    build_modules= builddb.modules(build_tag)
    module_dict= {}
    for modulespec in modulespecs:
        modulename= modulespec.modulename
        v= build_modules.get(modulename)
        if v is None:
            sys.exit("error: module %s not found in build %s" % \
                     (modulename, build_tag))
        if not modulespec.test(v):
            sys.exit("error: no module matching %s "
                     "found in build %s" % \
                     (modulespec.to_string(), build_tag))
        module_dict[modulename]= v
    get_dependencies(module_dict, db, builddb, build_tag)
    return fullapprelease(build_tag, builddb, db,
                          module_dict.keys(), aliases, extra_lines)

# -----------------------------------------------
# config subcommands
# -----------------------------------------------

def subcmd_config_list(arguments, options):
    """implement "config list"."""
    sumolib.cli.process_args(arguments, None, options.list)
    (_, config)= load_config_files(options, disable_loading= None)
    # ^^ disable_loading==None means: use options.disable_loading
    print "These configuration files were loaded:\n"
    print "\n".join(config.real_paths())
    return

def subcmd_config_make_show(cmd, arguments, options):
    """implement "config make" and "config show"."""
    argspec= sumolib.cli.CmdSpecs()
    if cmd=="make":
        argspec.add("CONFIGFILE", completion= sumolib.cli.complete_file)

    argspec.add("OPTIONNAMES", array= True, optional= True,
                completion= lambda o, r: \
                   sumolib.cli.complete_list(KNOWN_CONFIG_OPTIONS, o, r))

    args= sumolib.cli.process_args(arguments, argspec, options.list)

    if cmd=="make":
        filename= args.CONFIGFILE # pylint: disable=no-member
    else:
        filename= "-"

    (options, config)= load_config_files(options, disable_loading= None)
    # ^^ disable_loading==None means: use options.disable_loading
    if options.module:
        try:
            modulespecs_obj= sumolib.ModuleSpec.Specs.from_strings(\
                                 options.module,
                                 mspecs_from_build(options))
        except ValueError, e:
            if not catch_exceptions:
                raise
            sys.exit(errtxt("",e))
        config.set("module", modulespecs_obj.to_stringlist())
    if filename!="-" and os.path.exists(filename):
        if not sumolib.utils.ask_yes_no(
                "File %s already exists, overwrite ? (y/n)" % filename,
                options.yes):
            sys.exit(0)
    # pylint: disable=no-member
    config.save(filename, args.OPTIONNAMES, options.verbose, options.dry_run)

def subcmd_config_standalone(arguments, options):
    """implement "config standalone"."""
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("SUMODIR", completion= sumolib.cli.complete_dir)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    (options, config)= load_config_files(options, disable_loading= True)

    sumodir= os.path.abspath(args.SUMODIR) # pylint: disable=no-member
    if os.path.exists(sumodir):
        if not os.path.isdir(sumodir):
            sys.exit("error: '%s' is a file" % sumodir)
        # pylint: disable=no-member
        if not sumolib.utils.ask_yes_no(\
                "Directory '%s' already exists, use it ?" % args.SUMODIR,
                options.yes):
            sys.exit(0)
    ensure_dir(sumodir, options.dry_run)
    if not config.get("dbrepo"):
        sys.exit("error, dbrepo must be specified as command line option "
                 "or by config file")
    # set dbrepomode to "pull"
    if config.get("dbrepomode")=="push":
        # we don't want to use "push" here. Change to "pull" instead:
        config.set("dbrepomode", "pull")
    # create a dependency database file in subdir "database":
    dbdir= os.path.join(sumodir, "database")
    config.set("dbdir", dbdir)
    # the following does a checkout of the dependency database:
    _= repo_manager(dbdir,
                    config.get("dbrepo"),
                    config.get("dbrepomode"),
                    config.get("verbose"), config.get("dry_run"))
    builddir= os.path.join(sumodir, "build")
    config.set("builddir", builddir)
    ensure_dir(builddir, options.dry_run)
    config.save(CONFIG_NAME, None, options.verbose, options.dry_run)

def subcmd_config_local(arguments, options):
    """implement "config local"."""
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("SUMODIR", completion= sumolib.cli.complete_dir)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    (options, config)= load_config_files(options, disable_loading= True)
    sumodir= os.path.abspath(args.SUMODIR) # pylint: disable=no-member
    if os.path.exists(sumodir):
        if not os.path.isdir(sumodir):
            sys.exit("error: '%s' is a file" % sumodir)
        # pylint: disable=no-member
        if not sumolib.utils.ask_yes_no(\
                "Directory '%s' already exists, use it ?" % args.SUMODIR,
                options.yes):
            sys.exit(0)
    ensure_dir(sumodir, options.dry_run)
    if not config.get("dbrepo"):
        sys.exit("error, dbrepo must be specified as command line option "
                 "or by config file")
    # set dbrepomode to "pull"
    if config.get("dbrepomode")=="push":
        # we don't want to use "push" here. Change to "pull" instead:
        config.set("dbrepomode", "pull")
    # create a dependency database file in subdir "database":
    dbdir= os.path.join(sumodir, "database")
    config.set("dbdir", dbdir)
    # the following does a checkout of the dependency database:
    _= repo_manager(dbdir,
                    config.get("dbrepo"),
                    config.get("dbrepomode"),
                    config.get("verbose"), config.get("dry_run"))
    builddir= os.path.join(sumodir, "build")
    config.set("localbuilddir", builddir)
    ensure_dir(builddir, options.dry_run)
    config.save(CONFIG_NAME, None, options.verbose, options.dry_run)

# -----------------------------------------------
# db subcommands
# -----------------------------------------------

def subcmd_db_edit(arguments, options):
    """implement "db edit" maincommand."""
    if options.readonly:
        sys.exit("--readonly forbids editing a database file")
    sumolib.cli.process_args(arguments, None, options.list)

    sumolib.cli.assert_options(True, options, "dbdir")

    db_file= db_f(options.dbdir)
    db_tmp = db_file + ".edit.tmp"

    mylock= sumolib.lock.MyLock(db_file)
    try:
        mylock.lock()
    except sumolib.lock.LockedError, e:
        # cannot get lock
        if not catch_exceptions:
            raise
        sys.exit(str(e))
    except sumolib.lock.AccessError, e:
        # cannot create lock since we have no write access:
        if not catch_exceptions:
            raise
        sys.exit(str(e))

    try:
        shutil.copyfile(db_file, db_tmp)
        while True:
            sumolib.utils.edit_file(db_tmp, options.editor,
                                    options.verbose, options.dry_run)
            try:
                db= db_from_json_file(db_tmp, use_lock= False)
                break # leave while-loop
            except sumolib.JSON.ParseError, e:
                print "\nError: file has parse errors:"
                print str(e)
                reply= sumolib.utils.ask_yes_no("Re-edit the file (y) or "
                                                "abort (n) ? ")
                if not reply:
                    # "finally" will take care of the lock
                    sys.exit("aborting, your changes are in file %s" % db_tmp)

        if filecmp.cmp(db_file, db_tmp):
            # there were no changes
            print ("Note: no further action taken since %s was "
                   "not changed.") % DB
        else:
            mngr= repo_manager(options.dbdir, options.dbrepo,
                               options.dbrepomode,
                               options.verbose, options.dry_run)

            # the version control system should prompt for a log message if
            # none was given with --logmsg:
            db_to_repo(options, mngr, db, None, None)

        os.remove(db_tmp)
    finally:
        mylock.unlock()

def subcmd_db_convert(arguments, options):
    """implement "db convert"."""
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("SCANFILE", completion= sumolib.cli.complete_file)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    sumolib.cli.assert_options(True, options, "dbdir", "scandb")
    if os.path.exists(db_f(options.dbdir)):
        sys.exit("error, db file '%s' already exists" % db_f(options.dbdir))
    if os.path.exists(options.scandb):
        sys.exit("error, scandb file '%s' already exists" % \
                 options.scandb)
    scandata= sumolib.JSON.loadfile(args.SCANFILE) # pylint: disable=no-member
    deps= scandata["dependencies"]
    repoinfo= scandata["repos"]
    groups= scandata["groups"]
    (buildcache, db)= create_database(deps, repoinfo, groups,
                                      options.dir_patch,
                                      options.url_patch)
    mngr= repo_manager(options.dbdir, options.dbrepo, options.dbrepomode,
                       options.verbose, options.dry_run)
    mngr.prepare_read() # does a "pull"
    db_to_repo(options, mngr, db, "convert", arguments)
    try:
        buildcache.json_save(options.scandb,
                             options.verbose, options.dry_run)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while saving scan database file,",e))

def subcmd_db_convert_old(arguments, options):
    """implement "db convert-old"."""
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("OLDDB", completion= sumolib.cli.complete_file)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    sumolib.cli.assert_options(True, options, "dbdir")
    try:
        # pylint: disable=no-member
        olddb= sumolib.Dependencies.OldDB.from_json_file(args.OLDDB,
                                                         use_lock= True,
                                                         keep_lock= False)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while loading dependency database,", e))
    except IOError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("Error while loading dependency database,", e))
    db= olddb.convert()
    if options.dumpdb:
        db.json_print()
    else:
        db_to_repo(options, None, db, "convert-old", arguments)
        # ^^^ does also unlock the file

def subcmd_db_modconvert(arguments, options):
    """implement "db modconvert"."""
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("SCANFILE", completion= sumolib.cli.complete_file)
    argspec.add("MODULES", array= True, optional= True)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    modulespecs= []
    if options.module:
        modulespecs.extend(options.module)
    if args.defined("MODULES"):
        if "module" in options.append:
            modulespecs.extend(args.MODULES) # pylint: disable=no-member
        else:
            modulespecs= args.MODULES # pylint: disable=no-member

    try:
        modulespecs_obj= sumolib.ModuleSpec.Specs.from_strings(modulespecs,\
                                                        None)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    scandata= sumolib.JSON.loadfile(args.SCANFILE) # pylint: disable=no-member
    deps= scandata["dependencies"]
    repoinfo= scandata["repos"]
    groups= scandata["groups"]
    (_, db)= create_database(deps, repoinfo, groups,
                             options.dir_patch,
                             options.url_patch)
    if options.dump_modules:
        dump_modules(modulespecs_obj)
        sys.exit(0)
    if modulespecs:
        try:
            db= db.partial_copy_by_modulespecs(modulespecs_obj)
        except KeyError, e:
            if not catch_exceptions:
                raise
            # note: str(e) generates a string with quotes
            sys.exit(("Error, module %s not found in "
                      "dependency database") % str(e))
    db.json_print()

def subcmd_db_appconvert(arguments, options):
    """implement "db appconvert"."""
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("SCANFILE", completion= sumolib.cli.complete_file)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    scandata= sumolib.JSON.loadfile(args.SCANFILE) # pylint: disable=no-member
    deps= scandata["dependencies"]
    repoinfo= scandata["repos"]
    groups= scandata["groups"]
    struc= create_app_data(deps, repoinfo, groups)
    sumolib.JSON.dump(struc)

def subcmd_db_format(arguments, options):
    """implement "db format."""
    sumolib.cli.process_args(arguments, None, options.list)

    sumolib.cli.assert_options(True, options, "dbdir")
    (mngr, db)= db_from_repo(options, keep_locked= True, changes_check= False)
    if options.dumpdb:
        db.json_print()
    else:
        db_to_repo(options, mngr, db, "merge", arguments)
        # ^^^ does also unlock the file

def subcmd_db_weight(arguments, options):
    """implement "db weight"."""
    # pylint: disable=R0912
    #                          Too many branches
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("WEIGHT")
    argspec.add("MODULES", array= True,
                completion= sumolib.complete.moduleversion)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    try:
        weight= int(args.WEIGHT) # pylint: disable=no-member
    except ValueError, _:
        if not catch_exceptions:
            raise
        sys.exit("error: weight must be an integer")
    try:
        # pylint: disable=no-member
        modulespecs_obj= sumolib.ModuleSpec.Specs.from_strings(\
                                                        args.MODULES,
                                                        None)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    (mngr, db)= db_from_repo(options,
                             not options.dumpdb and (not options.dry_run))

    if options.dump_modules:
        dump_modules(modulespecs_obj)
        sys.exit(0)
    set_weight(db, weight, modulespecs_obj, options.trace)
    if options.dumpdb:
        db.json_print()
    else:
        db_to_repo(options, mngr, db, "weight", arguments)
        # ^^^ does also unlock the file

def subcmd_db_show(arguments, options):
    """implement "db show"."""
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MODULES", array= True, optional= True,
                completion= sumolib.complete.moduleversion)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    modulespecs= []
    if options.module:
        modulespecs.extend(options.module)
    if args.defined("MODULES"):
        if "module" in options.append:
            modulespecs.extend(args.MODULES) # pylint: disable=no-member
        else:
            modulespecs= args.MODULES # pylint: disable=no-member
    if not modulespecs:
        sys.exit("error: module specs missing")

    (_, db)= db_from_repo(options)
    try:
        modulespecs_obj= sumolib.ModuleSpec.Specs.from_strings(modulespecs,\
                                                        None)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    if options.dump_modules:
        dump_modules(modulespecs_obj)
        sys.exit(0)
    try:
        db= db.partial_copy_by_modulespecs(modulespecs_obj)
    except KeyError, e:
        if not catch_exceptions:
            raise
        # note: str(e) generates a string with quotes
        sys.exit(("Error, module %s not found in "
                  "dependency database") % str(e))
    db.json_print()

def subcmd_db_check(arguments, options):
    """implement "db check"."""
    sumolib.cli.process_args(arguments, None, options.list)
    sumolib.cli.assert_options(True, options, "dbdir")
    (_, db)= db_from_repo(options, keep_locked= False, changes_check= False)
    msg= db.check()
    print "\n".join(msg)

def subcmd_db_merge(arguments, options):
    """implement "db merge"."""
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("DB", completion= sumolib.cli.complete_file)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    sumolib.cli.assert_options(True, options, "dbdir")
    (mngr, db)= db_from_repo(options,
                             not options.dumpdb and (not options.dry_run))
    # pylint: disable=no-member
    db2= db_from_json_file(args.DB, True, keep_locked= False)
    db.merge(db2)
    if options.dumpdb:
        db.json_print()
    else:
        db_to_repo(options, mngr, db, "merge", arguments)
        # ^^^ does also unlock the file

def subcmd_db_alias_add(arguments, options):
    """implement "db alias_add"."""
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MODULE", completion= sumolib.complete.moduleversion)
    argspec.add("DEPENDENCY",
                completion= lambda d,r: \
                        sumolib.complete.dependency("MODULE", d, r))
    argspec.add("ALIAS")
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    # pylint: disable=no-member
    module_spec= sumolib.ModuleSpec.Spec.from_string(args.MODULE)
    try:
        module_spec.assert_exact()
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    (mngr, db)= db_from_repo(options,
                             not options.dumpdb and (not options.dry_run))
    db.add_alias(module_spec.modulename,
                 module_spec.versionname,
                 args.ALIAS, args.DEPENDENCY) # pylint: disable=no-member
    if options.dumpdb:
        db.json_print()
    else:
        db_to_repo(options, mngr, db, "alias-add", arguments)
        # ^^^ does also unlock the file

def subcmd_db_dependency_add(arguments, options):
    """implement "db dependency_add"."""
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MODULE", completion= sumolib.complete.moduleversion)
    argspec.add("DEPENDENCY", completion= sumolib.complete.module)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    # pylint: disable=no-member
    module_spec= sumolib.ModuleSpec.Spec.from_string(args.MODULE)
    try:
        module_spec.assert_exact()
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    (mngr, db)= db_from_repo(options,
                             not options.dumpdb and (not options.dry_run))
    db.add_dependency(module_spec.modulename,
                      module_spec.versionname,
                      args.DEPENDENCY) # pylint: disable=no-member
    if options.dumpdb:
        db.json_print()
    else:
        db_to_repo(options, mngr, db, "dependency-add", arguments)
        # ^^^ does also unlock the file

def subcmd_db_dependency_delete(arguments, options):
    """implement "db dependency_delete"."""
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MODULE", completion= sumolib.complete.moduleversion)
    argspec.add("DEPENDENCY",
                completion= lambda d,r: \
                        sumolib.complete.dependency("MODULE", d, r))
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    # pylint: disable=no-member
    module_spec= sumolib.ModuleSpec.Spec.from_string(args.MODULE)
    if module_spec.no_version_spec():
        sys.exit("module has no version")
    try:
        module_spec.assert_exact()
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    (mngr, db)= db_from_repo(options,
                             not options.dumpdb and (not options.dry_run))
    db.del_dependency(module_spec.modulename,
                      module_spec.versionname,
                      args.DEPENDENCY)
    if options.dumpdb:
        db.json_print()
    else:
        db_to_repo(options, mngr, db, "dependency-delete", arguments)
        # ^^^ does also unlock the file

def subcmd_db_releasefilename(arguments, options):
    """implement "db releasefilename"."""
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MODULE", completion= sumolib.complete.moduleversion)
    argspec.add("RELEASEFILENAME")
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    # pylint: disable=no-member
    module_spec= sumolib.ModuleSpec.Spec.from_string(args.MODULE)
    try:
        module_spec.assert_exact()
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    (mngr, db)= db_from_repo(options,
                             not options.dumpdb and (not options.dry_run))
    db.add_releasefile(module_spec.modulename,
                       module_spec.versionname,
                       args.RELEASEFILENAME)
    if options.dumpdb:
        db.json_print()
    else:
        db_to_repo(options, mngr, db, "releasefilename", arguments)
        # ^^^ does also unlock the file

def subcmd_db_clone_replace_version(command, arguments, options):
    """implement "db cloneversion/replaceversion"."""
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MODULE", completion= sumolib.complete.module)
    argspec.add("OLD-VERSION",
                completion= lambda v, r: \
                        sumolib.complete.version("MODULE", v, r))
    argspec.add("NEW-VERSION")
    argspec.add("SOURCESPEC", array= True, optional= True)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    do_replace= (command=="replaceversion")
    modulename= args.MODULE # pylint: disable=no-member
    sourcespec= args.SOURCESPEC # pylint: disable=no-member

    (mngr, db)= db_from_repo(options,
                             not options.dumpdb and (not options.dry_run))
    try:
        # pylint: disable=no-member
        db.patch_version(modulename,
                         args.OLD_VERSION, args.NEW_VERSION,
                         do_replace)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    if not sourcespec:
        # guess tag from versionname
        # pylint: disable=no-member
        changed= db.set_source_spec_by_tag(modulename,
                                           args.NEW_VERSION,
                                           args.NEW_VERSION)
    else:
        try:
            source_spec_obj= \
                sumolib.repos.SourceSpec.from_string_sourcespec(sourcespec)
        except ValueError, e:
            if not catch_exceptions:
                raise
            sys.exit(errtxt("Error,",e))
        # pylint: disable=no-member
        changed= db.set_source_spec(modulename, args.NEW_VERSION,
                                    source_spec_obj)
    print "Added module:"
    # pylint: disable=no-member
    report_db= db.partial_copy_by_list([(modulename, args.NEW_VERSION)])
    report_db.json_print()
    if not changed:
        print ("\nCAUTION: source specification of this module is "
               "identical with that of \n"
               "%s:%s, this is probably not what you want!") % \
               (modulename, args.OLD_VERSION)
    sumolib.utils.ask_abort("Proceed ? ", options.yes)
    if options.dumpdb:
        db.json_print()
    else:
        db_to_repo(options, mngr, db, command, arguments)
        # ^^^ does also unlock the file

def subcmd_db_clonemodule(arguments, options):
    """implement "db clonemodule"."""
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("OLD-MODULE", completion= sumolib.complete.module)
    argspec.add("NEW-MODULE")
    argspec.add("VERSIONS",
                completion= lambda v,r: \
                      sumolib.complete.dependency("NEW-MODULE", v, r),
                array= True, optional= True)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    (mngr, db)= db_from_repo(options,
                             not options.dumpdb and (not options.dry_run))
    # pylint: disable=no-member
    db.clonemodule(args.OLD_MODULE, args.NEW_MODULE,
                   args.VERSIONS)
    if options.dumpdb:
        db.json_print()
    else:
        db_to_repo(options, mngr, db, "clonemodule", arguments)
        # ^^^ does also unlock the file

def subcmd_db_list(arguments, options):
    """implement "db list"."""
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MODULES", completion= sumolib.complete.module,
                array= True, optional= True)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    (_, db)= db_from_repo(options)
    # NOTE: option "--modules" is NOT used here
    if not args.defined("MODULES"):
        # no modules given, list all module names:
        result= sorted(db.iter_modulenames())
        sumolib.JSON.dump(result)
        return

    modules= args.MODULES # pylint: disable=no-member
    result= {}

    if len(modules)==1 and modules[0]==".":
        # wildcard, list ALL versions of ALL modules:
        for modulename in db.iter_modulenames():
            versions= db.sorted_moduleversions(modulename)
            result[modulename]= versions
    else:
        # Modules are given, list only the given modules. The user may specify
        # ranges of moduleversions like MODULE:+VERSION or MODULE:-VERSION.
        try:
            modulespecs_obj= \
                    sumolib.ModuleSpec.Specs.from_strings(modules, None)
        except ValueError, e:
            if not catch_exceptions:
                raise
            sys.exit(errtxt("",e))
        if options.dump_modules:
            dump_modules(modulespecs_obj)
            return
        for modulespec in modulespecs_obj:
            modulename= modulespec.modulename
            # leave only versions that match modulespec:
            try:
                moduleversions= db.sorted_moduleversions(modulename)
            except KeyError, _:
                if not catch_exceptions:
                    raise
                sys.exit(("Error, module '%s' not found in "
                          "dependency database") % modulename)
            versions= [v for v in moduleversions if modulespec.test(v)]
            result[modulename]= versions
    sumolib.JSON.dump(result)

def subcmd_db_find(arguments, options):
    """implement "db find"."""
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("REGEXP")
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    sumolib.cli.assert_options(True, options, "dbdir")
    (_, db)= db_from_repo(options)
    if options.noignorecase:
        rx_flags= 0
    else:
        rx_flags= re.IGNORECASE
    rx= re.compile(args.REGEXP, rx_flags) # pylint: disable=no-member
    results= db.search_modules(rx)
    if options.brief:
        for (module,version) in results:
            print "%s:%s" % (module,version)
        return
    newdb= db.partial_copy_by_list(results)
    newdb.json_print()

# -----------------------------------------------
# build subcommands
# -----------------------------------------------

def subcmd_build_list(arguments, options):
    """implement "subcmd_build_list"."""
    sumolib.cli.process_args(arguments, None, options.list)

    sumolib.cli.assert_options(True, options, "builddir")
    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= False, must_exist= False)
    for buildtag in builddb.iter_builds():
        print buildtag

def subcmd_build_show(arguments, options):
    """implement "subcmd_build_show"."""
    sumolib.cli.assert_options(True, options, "builddir")
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("BUILDTAG", completion= sumolib.complete.builds)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    if options.buildtag:
        sys.exit("error: you cannot use --buildtag here")

    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= False)
    assert_build_tag(builddb, args.BUILDTAG) # pylint: disable=no-member
    new_builddb= sumolib.Builds.DB(use_lock= True, lock_timeout= LOCK_TIMEOUT)
    new_builddb.add_build(builddb, args.BUILDTAG) # pylint: disable=no-member
    new_builddb.json_print()

def subcmd_build_state(arguments, options):
    """implement "subcmd_build_state"."""
    sumolib.cli.assert_options(True, options, "builddir")
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("BUILDTAG", completion= sumolib.complete.builds)
    argspec.add("NEW-STATE", optional= True)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    if options.buildtag:
        sys.exit("error: you cannot use --buildtag here")

    buildtag = args.BUILDTAG # pylint: disable=no-member
    new_state= args.NEW_STATE # pylint: disable=no-member

    sumolib.cli.assert_options(True, options, "builddir")
    if options.readonly:
        sys.exit("--readonly forbids changing the state of a build")

    if not new_state:
        builddb= builddb_from_json_file(options.builddir,
                                        options.localbuilddir,
                                        keep_locked= False)
        assert_build_tag(builddb, buildtag)
        print "%-20s : %s" % (buildtag,
                              builddb.state(buildtag))
    else:
        builddb= builddb_from_json_file(options.builddir,
                                        options.localbuilddir,
                                        keep_locked= False)
        assert_build_tag(builddb, buildtag)
        # if assert_build_tag does sys.exit,
        # builddb __del__ method should remove lockfiles
        if new_state!="disabled":
            builds=set((buildtag,))
        else:
            builds=set([b for b in builddb.rec_linked_builds(buildtag)\
                          if not builddb.tag_is_overlayed(b)])
            if builds:
                print "The following builds depend on build %s:" % buildtag
                print " ".join(sorted(builds))
                sumolib.utils.ask_abort("Disabling %s would also disable "
                                        "these.\nProceed ? " % buildtag,
                                        options.yes)
            builds.add(buildtag)

        try:
            for b in builds:
                builddb.change_state(b, new_state)
        except ValueError, e:
            # builddb __del__ method should remove lockfiles
            if not catch_exceptions:
                raise
            sys.exit(errtxt("",e))
        builddb.json_save(None, options.verbose, options.dry_run)
        # ^^^ does also unlock the file

def subcmd_build_delete(arguments, options):
    """implement "subcmd_build_delete"."""
    sumolib.cli.assert_options(True, options, "builddir")
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("BUILDTAG", completion= sumolib.complete.builds)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    if options.readonly:
        sys.exit("--readonly forbids deleting a support")

    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= not options.dry_run)
    assert_build_tag(builddb, args.BUILDTAG) # pylint: disable=no-member
    try:
        # modifies builddb and deletes directories:
        # pylint: disable=no-member
        delete_modules(builddb, args.BUILDTAG,
                       options.verbose, options.dry_run)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    builddb.json_save(None, options.verbose, options.dry_run)

def subcmd_build_try(arguments, options):
    """implement "subcmd_build_try"."""
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0915
    #                          Too many statements
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MODULES", array= True, optional= True,
                completion= sumolib.complete.moduleversion)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    sumolib.cli.assert_options(True, options, "builddir")
    buildtag= options.buildtag

    exclude_matcher= sumolib.utils.RegexpMatcher(options.exclude_states)

    modulespecs= []
    if options.module:
        modulespecs.extend(options.module)
    if args.defined("MODULES"):
        if "module" in options.append:
            modulespecs.extend(args.MODULES) # pylint: disable=no-member
        else:
            modulespecs= args.MODULES # pylint: disable=no-member
    if not modulespecs:
        sys.exit("error: module specs missing")

    try:
        modulespecs_obj= sumolib.ModuleSpec.Specs.from_strings(\
                             modulespecs,
                             mspecs_from_build(options))
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    if options.dump_modules:
        dump_modules(modulespecs_obj)
        sys.exit(0)

    (_, db)= db_from_repo(options)
    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= False,
                                    must_exist= False)

    buildcache= init_buildcache(options.scandb,
                                builddb, db)

    # ensure that each module is only mentioned once in the modulelist:
    try:
        modulespecs_obj.assert_unique()
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    # gather a list of all modules that don't have an exact specification:
    modules_not_exact_spec= \
        [spec.modulename for spec in modulespecs_obj \
                         if not spec.is_exact_spec()]

    # convert modulespecs to a set dict:
    # { modulename1 : set(version1,version2),
    #   modulename2 : set(version1,version2),
    # }
    try:
        sets_dict= db.sets_dict(modulespecs_obj)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    except KeyError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    # add all missing dependencies and complete the sets_dict:
    added_modules= db.complete_sets_dict(sets_dict)

    was_built= set()
    needed_by_others= {}

    # examine the builds:
    # was_built is a set of (modulename,versionname) or modules
    #           that were built
    # needed_by_others is a dict mapping
    #           (depname,dep_version)->[(modulename,versionname,state)...]
    #           where state is the build state of the build the modules
    #           share

    for modulename in sets_dict.keys():
        for versionname in sets_dict[modulename]:
            if buildcache.was_built(modulename,versionname):
                was_built.add((modulename,versionname))
            for depname in db.iter_dependencies(modulename, versionname):
                for dep_version in sets_dict[depname]:
                    s= needed_by_others.setdefault((depname,dep_version),
                                                   [])
                    s.append((modulename,versionname,
                              buildcache.relation(modulename,versionname,
                                                  depname, dep_version)))

    # now build the report structure:
    report= {}
    for modulename in sets_dict.keys():
        mdict= report.setdefault(modulename, {})
        no_of_versions= len(sets_dict[modulename])
        for versionname in sets_dict[modulename]:
            d= {}
            mdict[versionname]= d
            d["built"]= (modulename,versionname) in was_built
            l= needed_by_others.get((modulename,versionname))
            if l is not None:
                dd= d.setdefault("dependents", {})
                depmods_versioncount= {}
                for (m,v,state) in l:
                    depmods_versioncount.setdefault(m, 0)
                    if state is None:
                        state= "state: not tested"
                    else:
                        state= "state: %s" % state
                    if no_of_versions>1:
                        # do only apply the exclude_matcher when there is
                        # more than one possible version of module
                        # 'modulename':
                        if exclude_matcher.search(state):
                            continue
                    depmods_versioncount[m]+= 1
                    dd["%s:%s" % (m,v)]= state
                if min(depmods_versioncount.values())==0:
                    # all versions of a dependent were removed,
                    # remove modulename:versionname completely:
                    del mdict[versionname]
        if not mdict:
            sys.exit("error: your '--exclude-states' option removes "
                     "*ALL* versions of module '%s'. You may change "
                     "the REGEXP or specify an exact version "
                     "for the module to avoid this error." % \
                     modulename)

    if options.detail:
        try:
            detail= int(options.detail)
        except ValueError, _:
            sys.exit("error, value for '--detail' must be 1, 2 or 3")
        wanted= set(modules_not_exact_spec)
        wanted.update(added_modules)
        if (detail==1) and wanted:
            print "Possible versions for unspecified/missing modules:\n"
            for m in sorted(wanted):
                l= ["%-19s" % m]
                l.extend(sorted(report[m].keys()))
                st= " ".join(l)
                print "\n".join(textwrap.wrap(st, width=70,
                                              subsequent_indent=" "*20))
            print
        elif (detail==2) and wanted:
            short_report= {}
            for (k,v) in report.items():
                if k in wanted:
                    short_report[k]= v
            report= short_report
            print "Details on unspecified/missing modules:\n"
            sumolib.JSON.dump(short_report)
        elif detail>=3:
            print "Details on all modules:\n"
            sumolib.JSON.dump(report)

    if modules_not_exact_spec:
        print "Not all modules have exactly specified versions.",
        print "These modules need an "
        print "exact version specification:"
        for m in sorted(modules_not_exact_spec):
            versions= report[m].keys()
            if len(versions)>1:
                print "    %s" % m
            else:
                print "    %-20s -> suggested version: %s" % \
                      (m,versions[0])
        print

    if added_modules:
        print "Not all dependencies were included in module",
        print "specifications, these modules"
        print "have to be added:\n   ",
        print "\n    ".join(sorted(added_modules))
        print

    if buildtag is None:
        buildtag= builddb_generate_tag(builddb, options.buildtag_stem,
                                       bool(options.localbuilddir))
        print "Command 'new' would create build with tag '%s'\n" % \
              buildtag

    if not modules_not_exact_spec and not added_modules:
        print "Your module specifications are complete. You can use",
        print "these with command"
        print "'new' to create a new build."
    else:
        print "Your module specifications are still incomplete,",
        print "command 'new' can not"
        print "be used with these."

def subcmd_build_remake(arguments, options):
    """call make distclean and make on a build."""
    sumolib.cli.assert_options(True, options, "builddir")
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("BUILDTAG", completion= sumolib.complete.builds)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    if options.buildtag:
        sys.exit("error: you cannot use --buildtag here")
    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= not options.dry_run)
    buildtag= args.BUILDTAG # pylint: disable=no-member
    builddb.change_state(buildtag, "unstable")
    builddb.json_save(None, options.verbose, options.dry_run)
    # ^^^ does also unlock the file
    builddir= get_builddir(options.builddir, options.localbuilddir)
    simple_call_make(builddir,
                     makefilename(builddir, buildtag),
                     "distclean",
                     options.makeflags if options.makeflags else [],
                     options.verbose, options.dry_run)
    simple_call_make(builddir,
                     makefilename(builddir, buildtag),
                     "all",
                     options.makeflags if options.makeflags else [],
                     options.verbose, options.dry_run)
    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= not options.dry_run)
    builddb.change_state(buildtag, "testing")
    builddb.json_save(None, options.verbose, options.dry_run)
    # ^^^ does also unlock the file

def subcmd_build_new(arguments, options):
    """implement "subcmd_build_new"."""
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0915
    #                          Too many statements
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MODULES", array= True, optional= True,
                completion= sumolib.complete.moduleversion)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    sumolib.cli.assert_options(True, options, "builddir")
    if options.readonly:
        sys.exit("--readonly forbids creating a new build")

    buildtag= options.buildtag

    modulespecs= []
    if options.module:
        modulespecs.extend(options.module)
    if args.defined("MODULES"):
        if "module" in options.append:
            modulespecs.extend(args.MODULES) # pylint: disable=no-member
        else:
            modulespecs= args.MODULES # pylint: disable=no-member
    if not modulespecs:
        sys.exit("error: module specs missing")

    (_, db)= db_from_repo(options)

    try:
        modulespecs_obj= sumolib.ModuleSpec.Specs.from_strings(\
                             modulespecs,
                             mspecs_from_build(options))
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    if options.dump_modules:
        dump_modules(modulespecs_obj)
        sys.exit(0)

    try:
        dist_dict= modulespecs_obj.to_dist_dict()
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    try:
        db.assert_complete_modulelist(dist_dict)
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    except KeyError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= not options.dry_run,
                                    must_exist= False)

    if buildtag is None:
        buildtag= builddb_generate_tag(builddb, options.buildtag_stem,
                                       bool(options.localbuilddir))
        notemsg("creating build with tag '%s'\n" % buildtag)

    if builddb.has_build_tag(buildtag):
        # builddb __del__ method should remove lockfiles
        sys.exit("error: buildtag \"%s\" already taken" % buildtag)
    # create a new build in builddb, initial state is "unstable":
    builddb.new_build(buildtag, "incomplete")
    # add all modules specified by dist_dict to builddb under tag build_tag:
    add_modules(dist_dict, db, builddb, buildtag)
    builddb.json_save(None, options.verbose, options.dry_run)
    # ^^^ does also unlock the file

    # the following function may raise IOError, if one of the checkout commands
    # fails:
    create_modules(dist_dict, db, builddb,
                   get_builddir(options.builddir, options.localbuilddir),
                   buildtag,
                   options.extra,
                   options.no_checkout,
                   options.verbose, options.dry_run)
    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= not options.dry_run,
                                    must_exist= False)
    builddb.change_state(buildtag, "unstable")
    builddb.json_save(None, options.verbose, options.dry_run)
    # ^^^ does also unlock the file
    if not options.no_checkout:
        create_makefile(dist_dict, db,
                        builddb,
                        buildtag,
                        options.verbose,
                        options.dry_run)

    if not options.no_make and not options.no_checkout:
        # call_make will set the build state to "testing" if it succeeds:
        call_make(buildtag, options)

def subcmd_build_find(arguments, options):
    """implement "subcmd_build_find"."""
    # pylint: disable=R0912
    #                          Too many branches
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MODULES", array= True, optional= True,
                completion= sumolib.complete.moduleversion)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    sumolib.cli.assert_options(True, options, "builddir")

    modulespecs= []
    if options.module:
        modulespecs.extend(options.module)
    if args.defined("MODULES"):
        if "module" in options.append:
            modulespecs.extend(args.MODULES) # pylint: disable=no-member
        else:
            modulespecs= args.MODULES # pylint: disable=no-member
    if not modulespecs:
        sys.exit("error: module specs missing")

    try:
        modulespecs_obj= sumolib.ModuleSpec.Specs.from_strings(\
                             modulespecs,
                             mspecs_from_build(options))
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= False)

    if options.dump_modules:
        dump_modules(modulespecs_obj)
        sys.exit(0)
    new_builddb= builddb.filter_by_modulespecs(modulespecs_obj)
    if new_builddb.is_empty():
        print "no matching buildtrees found"
    else:
        if options.brief:
            for buildtag in builddb.iter_builds():
                print buildtag
        else:
            new_builddb.json_print()

def subcmd_build_use(arguments, options):
    """implement "subcmd_build_use"."""
    # pylint: disable=too-many-branches
    # pylint: disable=too-many-statements
    sumolib.cli.assert_options(True, options, "dbdir")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MODULES", array= True, optional= True,
                completion= sumolib.complete.moduleversion)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    sumolib.cli.assert_options(True, options, "builddir")

    modulespecs= []
    if options.module:
        modulespecs.extend(options.module)
    if args.defined("MODULES"):
        if "module" in options.append:
            modulespecs.extend(args.MODULES) # pylint: disable=no-member
        else:
            modulespecs= args.MODULES # pylint: disable=no-member
    if not modulespecs:
        sys.exit("error: module specs missing")

    try:
        modulespecs_obj= sumolib.ModuleSpec.Specs.from_strings(\
                             modulespecs,
                             mspecs_from_build(options))
    except ValueError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))

    if options.dump_modules:
        dump_modules(modulespecs_obj)
        sys.exit(0)

    module_list_complete= None
    # ^^^ <None> until we check if the module list is complete
    if options.buildtag is None:
        # unspecifed build_tag, look if the module list is complete:
        try:
            dist_dict= modulespecs_obj.to_dist_dict()
        except ValueError, e:
            if not catch_exceptions:
                raise
            sys.exit(errtxt("",e))
        (_, db)= db_from_repo(options)
        try:
            db.assert_complete_modulelist(dist_dict)
            module_list_complete= True
        except ValueError, e:
            module_list_complete= False
        except KeyError, e:
            if not catch_exceptions:
                raise
            sys.exit(errtxt("",e))

    output= options.output
    if not output:
        _assume_dir("configure", options.dry_run)
        output= os.path.join("configure","RELEASE")

    (_, db)= db_from_repo(options)
    builddb= builddb_from_json_file(options.builddir,
                                    options.localbuilddir,
                                    keep_locked= False,
                                    must_exist= False)

    if options.dump_modules:
        dump_modules(modulespecs_obj)
        sys.exit(0)

    lines= apprelease(options.buildtag,
                      module_list_complete,
                      modulespecs_obj,
                      builddb,
                      db,
                      scan_aliases(options.alias),
                      options.extra)
    sumolib.utils.mk_text_file(output, lines,
                               options.verbose, options.dry_run)

# -----------------------------------------------
# command processing
# -----------------------------------------------

def maincmd_config(commands, options):
    """implement "config" maincommand."""
    # pylint: disable=R0911
    #                          Too many return statements
    # pylint: disable=R0912
    #                          Too many branches

    # note: the following function may exit the program when options.list is
    # given:
    (cmd, c_args)= sumolib.cli.process_cmd(commands, KNOWN_CONFIG_COMMANDS,
                                           options.list)

    if cmd=="list":
        subcmd_config_list(c_args, options)
        return

    if cmd=="make" or cmd=="show":
        subcmd_config_make_show(cmd, c_args, options)
        return
    if cmd=="standalone":
        subcmd_config_standalone(c_args, options)
        return
    if cmd=="local":
        subcmd_config_local(c_args, options)
        return

def maincmd_lock(arguments, options):
    """implement "lock" maincommand."""
    if options.readonly:
        sys.exit("--readonly forbids editing a database file")

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("FILE", completion= sumolib.cli.complete_file)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    l= sumolib.lock.MyLock(args.FILE) # pylint: disable=no-member
    try:
        l.lock()
    except sumolib.lock.LockedError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    except sumolib.lock.AccessError, e:
        if not catch_exceptions:
            raise
        sys.exit(errtxt("",e))
    # other exceptions like OSError are not caught here

def maincmd_unlock(arguments, options):
    """implement "unlock" maincommand."""
    if options.readonly:
        sys.exit("--readonly forbids editing a database file")
    argspec= sumolib.cli.CmdSpecs()
    argspec.add("FILE", completion= sumolib.cli.complete_file)
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    l= sumolib.lock.MyLock(args.FILE) # pylint: disable=no-member
    lock_found= False
    try:
        l.lock()
    except sumolib.lock.LockedError, _:
        lock_found= True
    except sumolib.lock.AccessError, _:
        # we cannot create a lock but it didn't exist anyway.
        pass
    if not lock_found:
        l.unlock()
        # pylint: disable=no-member
        sys.exit("error, cannot unlock '%s' since file wasn't locked" % \
                 args.FILE)
    l.unlock(force= True)

def maincmd_db(commands, options):
    """implement db maincommand."""
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0911
    #                          Too many return statements
    # pylint: disable=R0915
    #                          Too many statements
    if options.nolock:
        sumolib.lock.use_lockfile= False

    # note: the following function may exit the program when options.list is
    # given:
    (cmd, c_args)= sumolib.cli.process_cmd(commands, KNOWN_DB_COMMANDS,
                                           options.list)

    if cmd=="edit":
        subcmd_db_edit(c_args, options)
        return

    if cmd=="convert":
        subcmd_db_convert(c_args, options)
        return

    if cmd=="convert-old":
        subcmd_db_convert_old(c_args, options)
        return

    if cmd=="modconvert":
        subcmd_db_modconvert(c_args, options)
        return

    if cmd=="appconvert":
        subcmd_db_appconvert(c_args, options)
        return

    if cmd=="format":
        subcmd_db_format(c_args, options)
        return

    if cmd=="weight":
        subcmd_db_weight(c_args, options)
        return

    if cmd=="check":
        subcmd_db_check(c_args, options)
        return

    if cmd=="merge":
        subcmd_db_merge(c_args, options)
        return

    if cmd=="alias-add":
        subcmd_db_alias_add(c_args, options)
        return

    if cmd=="dependency-add":
        subcmd_db_dependency_add(c_args, options)
        return

    if cmd=="dependency-delete":
        subcmd_db_dependency_delete(c_args, options)
        return

    if cmd=="releasefilename":
        subcmd_db_releasefilename(c_args, options)
        return

    if cmd=="cloneversion" or cmd=="replaceversion":
        subcmd_db_clone_replace_version(cmd, c_args, options)
        return

    if cmd=="clonemodule":
        subcmd_db_clonemodule(c_args, options)
        return

    if cmd=="list":
        subcmd_db_list(c_args, options)
        return

    if cmd=="show":
        subcmd_db_show(c_args, options)
        return

    if cmd=="find":
        subcmd_db_find(c_args, options)
        return

def maincmd_build(commands, options):
    """implement build maincommand."""
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0911
    #                          Too many return statements
    # pylint: disable=R0915
    #                          Too many statements
    # pylint: disable=R0914
    #                          Too many local variables
    if options.nolock:
        sumolib.lock.use_lockfile= False

    # make the build directories absolute:
    if options.builddir:
        options.builddir= os.path.abspath(options.builddir)
    if options.localbuilddir:
        options.localbuilddir= os.path.abspath(options.localbuilddir)

    # note: the following function may exit the program when options.list is
    # given:
    (cmd, c_args)= sumolib.cli.process_cmd(commands, KNOWN_BUILD_COMMANDS,
                                           options.list)

    if not options.extra:
        options.extra= []

    if cmd=="list":
        subcmd_build_list(c_args, options)
        return

    if cmd=="show":
        subcmd_build_show(c_args, options)
        return

    if cmd=="state":
        subcmd_build_state(c_args, options)
        return

    if cmd=="delete":
        subcmd_build_delete(c_args, options)
        return

    if cmd=="try":
        subcmd_build_try(c_args, options)
        return

    if cmd=="new":
        subcmd_build_new(c_args, options)
        return

    if cmd=="remake":
        subcmd_build_remake(c_args, options)
        return

    if cmd=="find":
        subcmd_build_find(c_args, options)
        return

    if cmd=="use":
        subcmd_build_use(c_args, options)
        return

# -----------------------------------------------
# help text display
# -----------------------------------------------

def print_summary():
    """print a short summary of the scripts function."""
    print "%-20s: a tool for managing support EPICS trees \n" % \
          script_shortname()

def _test():
    """does a self-test of some functions defined here."""
    print "performing self test..."
    import doctest
    doctest.testmod()
    print "done!"

# pylint: disable=C0330
#                          Wrong indentation

help_topics= {
        "":"""
No help topic given. Use
  "help <topic>" to get help on a topic.

Possible topics are:

  maincommand                : explain and list maincommands
  completion                 : how to install and use command completion
  pager                      : how to configure the help pager
  configuration              : how and where configuration data is stored
  options                    : explain what an option is
  listoptions                : list all options
  <maincommand>              : help for a specific maincommand
  <maincommand> <subcommand> : help for a subcommand of a maincommand
  <subcommand>               : help for a subcommand
""",
        "maincommand":"""
A maincommand provides a grouping for the various commands of sumo.

While some maincommands can be used without a subcommand, others must be
followed by a subcommand. These are the known maincommands:

  config [subcommand] - operations on configuration files
  edit FILE           - lock, then edit a file
  lock FILE           - just lock a file
  unlock FILE         - unlock a file
  db [subcommand]     - operation on the dependency database
  build [subcommand]  - manage the build database and builds

For all of the db subcommands you have to specify the dependency database
directory with option --dbdir or a configuration file.

For all of the build subcommands you have to specify the dependency database
directory and the build directory with --dbdir and --builddir or a
configuration file.

Use "help [maincommand] for further details.
""",
        "completion":"""
Command completion means that you can press <TAB> on any incomplete sumo
command and you get a list of possibilities how to complete that command. By
pressing <TAB> several times you can try each possible completion.

Command completion is tested with the shells "bash" and "zsh". In order to
activate this feature you have to configure your shell. There are two ways to
do this:

Activate command completion on the fly:

  Enter this command:
    eval `sumo help completion-line`

Activate command completion permanently:

  Enter this command:
    sumo help completion-script > $HOME/_sumo
  Then add 
    "source $HOME/_sumo" 
  to your $HOME/.bashrc or $HOME/.zshrc

Cache files:

Sumo will create cache files in your home directory to speed up command
completion. If you don't want this set the environment variable "SUMOHELP" that
it contains the string "nocache" like in:

  export SUMOHELP="nocache"

If there are other help options defined in SUMOHELP, you should seperate them
with commas ",".
""",
        "completion-script":"""
_sumo()
{
    local cnt
    local words

    if [ $(basename $SHELL) = "bash" ]; then
        # The following function is only available in bash. It is needed in
        # order to treat the ":" character within modulespecs like
        # "MCAN:R2-3":
        __reassemble_comp_words_by_ref : words cnt
    else
        # With zsh the ":" character doesn't need special treatment here:
        words=( ${COMP_WORDS[@]} )
        cnt=${#words[@]}
    fi

    if [[ $COMP_LINE == *[[:space:]] ]]; then
      # When the last entered character was a space before <TAB> was pressed,
      # this final space cannot be seen by sumo (the shell seems to filter it).
      # In order to communicate this to sumo, we use option --listnew instead
      # of option --list:
      words+=(--listnew)
    else
      # Append option "--list" which tells sumo that we want command
      # completion:
      words+=(--list)
    fi

    # Note that in sumo in module cli, environment variable SHELL is evaluated.
    # If it is "zsh", the completion output of sumo for modulespecs like
    # "MCAN:R2-3" is different.

    ## the resulting completions should be put into this array
    COMPREPLY=( $( compgen -W "$( ${words[@]} )" ) )

}

complete -F _sumo sumo
""",
        "completion-line":"""
_sumo()
{
    local cnt;
    local words;
    if [ $(basename $SHELL) = "bash" ]; then
        __reassemble_comp_words_by_ref : words cnt;
    else
        words=( ${COMP_WORDS[@]} );
        cnt=${#words[@]};
    fi;
    if [[ $COMP_LINE == *[[:space:]] ]]; then
      words+=(--listnew);
    else
      words+=(--list);
    fi;
    COMPREPLY=( $( compgen -W "$( ${words[@]} )" ) );
};
complete -F _sumo sumo
""",
        "pager":"""
pager

The build in pager allows you to navigate in long help texts that sumo displays
when you use command "help" or option "-h". There are three modes:

pager:on
  The pager is used only for long help texts (more than 24 lines).

pager:always
  The pager is always used, even for short help texts.

Mode "pager:on" is the default.

You define the pager mode by adding one of the three strings to the environment
variable "SUMOHELP" like in:

    export SUMOHELP="pager:off"

If there are other help options defined in SUMOHELP, you should seperate them
with commas ",".

""",
        "configuration":"""

The philosphy
-------------

In sumo you can always specify all parameters for a command with command line
options and arguments. Configuration files are files that have defaults for
command line options. 

All command line options start with a dash "-". Short command line options have
the form "-<char>", long command line options have the form "--<string>".

All command line options have a long form, some also have a short form.

Some command line options take no argument, some options require an argument.
Some command line options may be given more than once with an argument, they
are used to define lists of values.

The configuration file defines a map where keys are names of long command line
options and values are booleans, strings or lists of strings. Only some of the
command line options can be put in a configuration file. 

You find a list of these at the end of this helptext.

File format
-----------

A configuration file is always in JSON format. Each key is the long name of a
command line option, each value is a boolean, a string or a list of strings.

Here is an example of such a file:

  {
      "dbdir": "/opt/Epics/sumo/database",
      "makeflags": [
          "-s"
      ],
      "builddir": "/opt/Epics/sumo/build"
  }

Environment variable expansion
------------------------------

A few keys in the configuration file of sumo have environment variable
expansion. This means that strings of the form "$VARNAME" are substituted
with the value of environment variable "VARNAME" if it exists. If you want to
use the string "$VARNAME" literally, precede it with a backslash like in
"\\$VARNAME". 

The list of configuration keys at the end of this file shows you which ones
have environment variable expansion.

Using more than one configuration file
--------------------------------------

Sumo can read more than just one configuration file, in this case the data is
*merged*.

The files are read one by one and their keys and values are combined in the in
the following way:

Keys not yet defined are simply added. For keys that already exist and whose values
are not lists, the last value overwrites the first one.  For keys that
already exist and whose values are lists, the lists are concatenated.

Default paths
-------------

Sumo reads and merges configuration files from various places, which one
depends on your environment variable settings and command line options. 

First the program tries to read the file sumo.config from a list of default
paths. The list of default paths can be set by the environment variable
SUMOCONFIG which must be a colon (on Unix systems) or semicolon (on Windows
systems) separated list of paths. 

If SUMOCONFIG *is not set*, these are the predefined default paths:

- /etc
- [python-libdir]/sumolib
- $HOME
- your current working directory

Note the sumo reads *all* the configuration files it finds, not just the first
one.

If you use the ``--no-default-config`` command line option, the list of default
paths is made empty.

The config option
-----------------

After the configuration files from default paths were read the program reads
the all configuration files specified by the "-c" or "--config" option.

Load commands in configuration files
-------------------

In a configuration file you can specify names of other configuration files that
must or may be loaded. These files are merged as described above.

There are 4 special keys in the configuration file that are used to specify
other files:

#preload [file list]
  Load files *before* all other definitions

#opt-preload [file list]
  Load files *before* all other definitions, if they exist. 

#postload [file list]
  Load files *after* all other definitions

#opt-postload [file list]
  Load files *after* all other definitions, if they exist.

Note that the loaded files can also contain one or more these special keys.

The default filename for the sumo configuration file
----------------------------------------------------

The default filename of this file is sumo.config.

Keys in the sumo configuration file
+++++++++++++++++++++++++++++++++++

This is the list of keys that may be used in a configuration file, for the
meanings of the keys see the sumo command line option. Call it with
"sumo -h --[optionname]".

#preload       [list of strings]
#opt-preload   [list of strings]
#postload      [list of strings]
#opt-postload  [list of strings]
alias          [list of strings]
buildtag_stem  [string]
dbdir          [string], environment variable expansion
dbrepo         [string], environment variable expansion
dbrepomode     [string]
editor         [string]
extra          [list of strings]
makeflags      [list of strings]
module         [list of strings]
progress       [boolean]
readonly       [boolean]
scandb         [string]
dir-patch      [list of strings]
url-patch      [list of strings]
builddir       [string], environment variable expansion
localbuilddir  [string], environment variable expansion
verbose        [boolean]
""",
        "options":"""
Options always start with a dash "-". All options have one of these two forms:
    -<letter>
    --<string>

Some options require an option argument.

You get help for all command line options with:

sumo -h

You get help for a specific option with:

sumo -h option
""",
        "listoptions":"""
You can display a list of all options with:

sumo -h
""",
        "help":"""
help

This command prints help for the given command. It can be invoked as::

  help
  help MAINCOMMAND
  help SUBCOMMAND
  help MAINCOMMAND SUBCOMMAND

You get a list of all known MAINCOMMANDS with:

  help maincommand
""",
        "config":"""
config [subcommand]

Show the configuration or create or modify a configuration file. These are
known subcommands here:

  list       - list loaded configuration files
  show       - show configuration data
  make       - create configuration file
  standalone - create configuration for "standalone" builds
  local      - create configuration for "local" builds

Use "help [subcommand] for further details.
""",
        "config list":"""
config list

List all configuration files that were loaded.
""",
        "config show":"""
config show [OPTIONNAMES]

Show the configuration in JSON format.  OPTIONNAMES is an optional list of long
option names. If OPTIONNAMES are specified, only options from this list are
saved in the configuration file.
""",
        "config make":"""
config make FILENAME [OPTIONNAMES]

Create a new configuration file from the options read from configuration files
and options from the command line. If FILENAME is '-' dump to the console. 
OPTIONNAMES is an optional list of long option names. If OPTIONNAMES are 
specified, only options from this list are saved in the configuration file.
""",
        "config standalone":"""
config standalone DIRECTORY

This command is used to create a new sumo directory with an independent build
directory and an independent copy of the dependency database. 

DIRECTORY is created if it does not yet exist. This command takes all settings
and command line options but sets dbrepomode to "pull" and dbdir to
DIRECTORY/database. It also sets builddir to DIRECTORY/build. Option dbrepo
must be set, this is used to create a local copy of the dependency database in
DIRECTORY/database. If there is a file "sumo.config" in the current working
directory it is copied to "sumo.config.bak". A new file "sumo.config" is then
created in the current working directory.
""",
        "config local":"""
config local DIRECTORY

This command is used to create a new sumo directory with a new build directory
but using existing builds from your current build directory. It also creates an
independent copy of the dependency database. 

DIRECTORY is created if it does not yet exist. This command takes all settings
and command line options but sets dbrepomode to "pull" and dbdir to
DIRECTORY/database. It also sets localbuilddir to DIRECTORY/build. Option
dbrepo must be set, this is used to create a local copy of the dependency
database in DIRECTORY/database. If there is a file "sumo.config" in the current
working directory it is copied to "sumo.config.bak". A new file "sumo.config"
is then created in the current working directory.
""",
        "lock": """
lock FILE

Lock a FILE, then exit sumo. This is useful if you want to read or write a
database file without sumo interfering. Don't forget to remove the lock later
with the "unlock" command.
""",
        "unlock": """
unlock FILE

Unlock a FILE, then exit sumo. If you locked a database with "lock" before you
should always unlock it later, otherwise sumo can't access the file.
""",
        "db": """

db [subcommand]

Query or modify the dependency database (DB) file. These are the known
subcommands here:

  convert      - convert a scanfile created by sumo-scan to a DB file
  convert-old  - convert DB file from old to new format
  appconvert   - convert a scanfile to a MODULES file for an application
  modconvert   - convert a scanfile to DB file format for a list of supports
  edit         - edit the dependency file with an editor
  format       - reformat the dependency file
  weight       - set the weight factor for modules
  alias-add    - add an alias for a dependency in a module
  dependency-add - 
                 add a dependency to a module
  dependency-delete - 
                 delete a dependency of a module
  list         - list modules or versions of modules
  show         - show details of moduleversions
  find         - search for modules with a regexp
  check        - consistency check of the DB file
  merge        - merge two DB files
  cloneversion - create a new DB entry by copying an old one
  releasefilename -
                 define an alternative filename for the RELEASE file
  replaceversion - 
                 replace a DB entry with a new one
  clonemodule  - add a module under a new name in the DB file

Use "help [subcommand] for further details.
""",
        "build": """

build [subcommand]

Manage the build database (BUILDDB) and create or delete builds. These are the
known subcommands:

  try       - check the module specification for completeness and consistency
  new       - create a new build
  remake    - do "make distclean" and "make all" with a build
  find      - look for builds that match a module specification
  use       - use all modules or your module specification in your application
  list      - list names of all builds
  show      - show details of a build
  state     - show or change the state of a build
  delete    - delete a build
""",
        "db convert":"""
db convert SCANFILE

Convert SCANFILE created by "sumo-scan all" to a new dependency database. If
SCANFILE is a dash "-" the program expects the scanfile on stdin. Note that
options "--dbdir" and "--scandb" are mandatory here. With "--dbdir" you specify
the drectory where the new created dependency database file is stored, with
"--scandb" you specify the name of the scan database file.  The scan database
file contains information on what moduleversion can be used with what
dependency version.
""",
        "db convert-old":"""
db convert OLDDB

Convert a dependency database file OLDDB from old to new format. The old format
had architecture data ("arch") for each moduleversion. In the new format this
data is removed. Note that this command IGNORES option "--dbrepo", it directly
operates on the dependency database file in the directory given with option
"--dbdir".
""",
        "db appconvert":"""
db appconvert SCANFILE

Convert a scanfile that was created by applying "sumo-scan all" to an
application to a list of aliases and modulespecs in JSON format. If SCANFILE is
a dash "-" the program expects the scanfile on stdin. The result is printed to
the console. 
""",
        "db modconvert":"""
db modconvert SCANFILE MODULES

Convert a scanfile that was created by applying "sumo-scan all" to the
dependency database format for all the selected modules. If SCANFILE is a dash
"-" the program expects the scanfile on stdin. The result is printed to the
console. This data can be added to the dependency database using the command
"db edit".
""",
        "db edit": """
db edit

Start the editor specified by option --editor or the environment variables
"VISUAL" or "EDITOR" to edit the dependency database file. This command first
aquires a file-lock on the file, that prevents other users from acessing the
file at the same time.  When the editor program is terminated, sumo checks if
the file is still a valid JSON file. If not, you can start the editor again or
abort the program. If the file is valid JSON, sumo commits the changes if
option --dbrepo was specified.  If option --logmsg was given, this is used as
commit log message, otherwise an editor is started where you can enter a log
message.  Finally the file lock is released. If you want to edit the dependency
database file you should always do it with this command.
""",
        "db format": """
db format

Just load and save the dependency database. This ensures that the file is
formatted in the standard sumo format. This is useful when the file was edited
and you want to ensure that key sort order and indentation are restored. If you
specified a repository with --dbrepo, the command will commit the changes. If
you want a log message different from "db format" use option --logmsg. 
""",
        "db weight": """
db weight WEIGHT MODULES

Set the weight factor for module. A weight determines where a module is placed
in the generated RELEASE file. Modules there are sorted first by weight, then
by dependency. Parameter MODULES is a list of modulespecs. Use
modulename:{+-}versionname to select more versions of a module.

Note that this command *does not* use the "--modules" option.

Parameter WEIGHT must be an integer.
""",
        "db alias-add": """
db alias-add MODULE DEPENDENCY ALIAS

Define a new alias for a dependency of a module. MODULE here is a modulespec of
the form MODULE:VERSION that specifies a single version of a module.
""",
        "db dependency-delete": """
db dependency-delete MODULE DEPENDENCY

Delete a dependency of a module. MODULE here is a modulespec of the form
MODULE:VERSION that specifies a single version of a module.
""",
        "db dependency-add": """
db dependency-add MODULE DEPENDENCY

Add a dependency to a module. MODULE here is a modulespec of the form
MODULE:VERSION that specifies a single version of a module.
""",
        "db list": """
db list [MODULES]

If called with no argument, list the names of all modules. If called with '.',
the wildcard symbol, list all versions of all modules. If called with argument
MODULES, a list of modulespecs MODULE:{+-}VERSION that specifies modules and
versions, list all the matching versions of all specified modules.
""",
        "db show": """
db show [MODULES]

This command prints only the parts of the dependency database that contain the
given modules. 

Parameter MODULES is a list of modulespecs MODULE:{+-}VERSION that specifies
the modules and versions to operate on. 
""",
        "db find": """
db find REGEXP

Show all modules whose names or sources match regexp.
""",
        "db check": """
db check 

Do some consistency checks on the dependency database file in the directory
specifed by --dbdir.
""",
        "db merge": """
db merge DB

Merge the given dependency database file with the dependency database in the
directory specifed by --dbdir.
""",
        "db cloneversion": """
db cloneversion MODULE OLD-VERSION NEW-VERSION [SOURCESPEC]

This command adds a new version of a module to the dependency database by
copying the old version. MODULE here is just the name of the module since the
version follows as a separate argument.  If sourcespec is given, the command
changes the source part according to this parameter. A sourcespec has the form
"path PATH", "tar TARFILE [PATCHES]", "REPOTYPE URL" or "REPOTYPE URL TAG
[PATCHES]". REPOTYPE may be "darcs", "hg" or "git". Both, URL or TAG may be
".", in this case the original URL or TAG remain unchanged. PATCHES is a list
of patchfiles or URLs of patchfiles. If sourcespec is not given, the command
adds NEW-VERSION as new tag to the source specification. The command always
asks for a confirmation of the action unless option "-y" is used.

""",
        "db releasefilename": """
db releasefilename MODULE RELEASEFILENAME

This command defines an alternative filename for the RELEASE file of the
module. Usually the RELEASE file is generated as "configure/RELEASE". You can
specify a different filename for the given module with this command. This may
be useful for support modules that have no regular EPICS makefile system or for
some special configurations of the EPICS base. If you set the RELEASEFILENAME
to an empty string or "configure/RELEASE", the special entry for the filename
is removed for this module in the dependency database.
""",
        "db replaceversion": """
db replaceversion MODULE OLD-VERSION NEW-VERSION

This command replaces a version of a module with a new
version. MODULE here is just the name of the module since the version
follows as a separate argument. All the data of the module is copied.
If sourcespec is given, the command changes the source part according to this
parameter. A sourcespec has the form "path PATH", "tar TARFILE", "REPOTYPE URL"
or "REPOTYPE URL TAG".  REPOTYPE may be "darcs", "hg" or "git". Both, URL or
TAG may be ".", in this case the original URL or TAG remains unchanged.
""",
        "db clonemodule": """
db clonemodule OLD-MODULE NEW-MODULE [VERSIONS]

Copy all versions of the existing old module and add this with the name of thew
new module to the dependency database.  OLD-MODULE and NEW-MODULE here are just
the module names since the versions may follow as a separate argument. If there
are no versions specified, the command copies all existing versions. Note that
this DOES NOT add the new module as dependency to any other modules.
""",
        "build try": """
build try MODULES

This command is intended to help you create module specifications for the "new"
command. 

Each MODULE here is a modulespec of the form MODULE or MODULE:{+-}VERSION that
specifies just a module name, a module and some versions or a single version.
You can specify an incomplete list of modules.

The detail of the output is determined by option "--detail" which is an integer
between 0 and 3. 0, the default, gives the shortest, 3 gives the longest
report. The program then shows which modules you have to

In any case the command shows which modules are missing since they depend on
other modules of your specification and which ones are missing an exact
version.

If you converted an existing support directory to sumo you have a scan database
file which you can specify with option "--scandb" to this command.

For a detailed example see the try example in the HTML documentation.
""",
        "build new": """
build new MODULES

This command creates a new build. Each module given in MODULES here is
a modulespec of the form MODULE:VERSION that specifies a single version
of a module. If the buildtag is not given as an option, the program
generates a buildtag in the form "AUTO-nnn". A new build is
created according to the modulespecs. Your modulespecifications must be
*complete* and *exact* meaning that all dependencies are included and
all modules are specified with exactly a single version. Use
command "try" in order to create module specifications that can be used
with command "new".  This command calls "make" and, after successful
completion, sets the state of the build to "testing". If you want to
skip this step, use option "--no-make". In order to provide arbitrary options
to make use option "--makeflags". 
""",
        "build remake": """
build remake BUILDTAG

This command recreates a build by first calling "make distclean" and then "make
all" with the build's makefile. If you develop a support module (see also
"config standalone" and "config local") you want to recompile the build after
changes in the sources. In order to provide arbitrary options
to make use option "--makeflags". 
""",
        "build find": """
build find MODULESPECS

This command is used to find matching builds for a given list of modulespecs.
Each module in MODULES here is a modulespec of the form MODULE or
MODULE:{+-}VERSION that specifies just a module name, a module and some
versions or a single version. The command prints a list of buildtags of
matching builds on the console. If option --brief is given, the program just
shows the buildtags. 

""",
        "build use": """
build use MODULES

This command creates a configure/RELEASE file for an application. Each module
given in MODULES here is a modulespec of the form MODULE:VERSION that specifies
a single version of a module. If option --buildtag is given, it checks if this
is compatible with the given modules.  Otherwise it looks for all builds that
have the modules in the required versions. If more than one matching build
found it takes the one with the alphabetically first buildtag. The RELEASE file
created includes only the modules that are specified. Output to another file or
the console can be specified with option '-o'.
""",
        "build list": """
build list    

This command lists the names of all builds.
""",
        "build show": """
build show BUILDTAG

This command shows the data of a build. The buildtag must be given as an 
argument.
""",
        "build state": """
build state BUILDTAG [NEW-STATE]

This command is used to show or change the state of a build. The buildtag
must be given as an argument. If there is no new state given, it just shows
the current state of the build. Otherwise the state of the build is changed
to the given value. 
""",
        "build delete": """
build delete BUILDTAG

If no other build depends on the build specified by the buildtag, the
directories of the build are removed and it's entry in the builddb is
deleted. The buildtag must be given as an argument.
""",
}

option_help_topics= {
        "help":"""
-h [OPTIONS]
--help [OPTIONS]
    If other OPTIONS are given, show help for these options. If OPTIONS is
    'all', show help for all options. If OPTIONS is missing, show a short
    generic help message for the program.
""",
        "summary":"""
--summary
    Print a summary of the function of the program.
""",
        "test":"""
--test
    Perform simple self-test.
""",
        "config":"""
-c CONFIGFILE
--config CONFIGFILE
    Load options from the given configuration file. You can specify more than
    one of these.  Unless --no- default-config is given, the program always
    loads configuration files from several standard directories first before it
    loads your configuration file. The contents of all configuration files are
    merged.
""",
        "no_default_config":"""
-C
--no-default-config
    If this option is given the program doesn't load the default configuration.
""",
        "disable_loading":"""
--disable-loading
    If given, disable execution of load commands like '#preload' in
    configuration files. In this case these keys are treated like ordinary
    keys.
""",
        "append":"""
-A OPTIONNAME
--append OPTIONNAME
    If an option with name OPTIONNAME is given here and it is a list option,
    the list from the command line is *appended* to the list from the
    configuration file.  The default is that options from the command line
    *override* option values from the configuration file.
""",
        "#preload":"""
--#preload FILES
    Specify a an '#preload' directive in the configuration file. This option
    has only a meaning if a configuration file is created with the 'makeconfig'
    command. '#preload' means that the following file(s) are loaded before the
    rest of the configuration file.
""",
        "#opt_preload":"""
--#opt-preload FILES
    This option does the same as --#preload but the file loading is optional.
    If they do not exist the program continues without an error.
""",
        "#postload":"""
--#postload FILES
    Specify a an '#postload' directive in the configuration file. This option
    has only a meaning if a configuration file is created with the 'makeconfig'
    command. '#postload' means that the following file(s) are loaded after the
    rest of the configuration file.
""",
        "#opt_postload":"""
--#opt-postload FILES
    This option does the same as --#postload but the file loading is optional.
    If they do not exist the program continues without an error.
""",
        "dbdir":"""

--dbdir DBDIR
    Define the directory where the dependency database file 'DEPS.DB' is found.
    A default for this option can be put in a configuration file.
""",
        "dbrepomode":"""
--dbrepomode MODE
    Specify how sumo should use the dependency database repository. There are
    three possible values: 'get', 'pull' and 'push'. Mode 'get' is the default.
    The meaning depends on the used version control system (VCS), if it is
    distributed (git,mercurial,darcs) or centralized (subversion,cvs). There
    are three possible operations on the dependency database:

      * init : create the dependency database if it doesn't exist
      * read : read the dependency database
      * write: write (change) the dependency database

    Here is what happens during these operations depending on the mode:

    mode   operation  action
    ------------------------------------------------
    get    init       create the repository if it doesn't exist
           read       none
           write      distr. VCS: commit changes
                      centr. VCS: none

    pull   init       create the repository if it doesn't exist
           read       distr. VCS: pull
                      centr. VCS: update 
           write      distr. VCS: commit changes
                      centr. VCS: none

    push   init       create the repository if it doesn't exist
           read       distr. VCS: pull
                      centr. VCS: update 
           write      distr. VCS: pull, commit changes, push
                      centr. VCS: update, commit changes
""",
        "dbrepo":"""
--dbrepo REPOSITORY
    Define a REPOSITORY for the DB file. REPOSITORY must consist of 'REPOTYPE
    URL', REPOTYPE may be 'darcs', 'hg' or 'git'. Option --dbdir must specify a
    directory that will contain the repository for the db file.  Before reading
    the db file a 'pull' command will be executed. When the file is changed, a
    'commit' and a 'push' command will be executed. If the repository doesn't
    exist the program tries to check out a working copy from the given URL. A
    default for this option can be put in a configuration file.
""",
        "scandb":"""
--scandb SCANDB
    Specify the (optional) SCANDB file. The scan database file contains
    information on what moduleversion can be used with what dependency version.
""",
        "dumpdb":"""
--dumpdb
    Dump the db on the console, currently only for these commands : format
    weight merge clonemodule cloneversion replaceversion.
""",
        "logmsg":"""
--logmsg BUILDTAG
    Specify a logmessage for automatic commits
""",
        "editor":"""
--editor EDITOR
    Specify the preferred editor. If this is not given, sumo takes the name of
    the editor from environment variables "VISUAL" or EDITOR".
""",
        "buildtag":"""
-t BUILDTAG
--buildtag BUILDTAG
    Specify a buildtag
""",
        "buildtag_stem":"""
--buildtag-stem STEM
    Specify the stem of a buildtag. This option has only an effect on the
    commands 'new' and 'try' if a buildtag is not specified. The program
    generates a new tag in the form 'stem-nnn' where 'nnn' is the smallest
    possible number that ensures that the buildtag is unique.
""",
        "builddir":"""

--builddir BUILDDIR
    Specify the support directory. If this option is not given take the current
    working directory as support directory. A default for this option can be
    put in a configuration file.
""",
        "localbuilddir":"""
--localbuilddir BUILDDIR
    Specify a local support directory. Modules from the directory specifed by
    --builddir are used but this directory is not modfied. All new builds are
    created in the local build directory and only the build database file there
    is modified.
""",
        "output":"""
-o OUTPUTFILE
--output OUTPUTFILE
    Define the output for command 'use'. If this option is not given, 'use'
    writes to 'configure/RELEASE'. If this option is '-', the command writes to
    standard-out.
""",
        "extra":"""
-x EXTRALINE
--extra EXTRALINE
    Specify an extra line that is added to the generated RELEASE file. A
    default for this option can be put in a configuration file.
""",
        "alias":"""
-a ALIAS
--alias ALIAS
    Define an alias for the command 'use'.  An alias must have the form
    FROM:TO. The path of module named 'FROM' is put in the generated RELEASE
    file as a variable named 'TO'. You can specify more than one of these by
    repeating this option or by joining values in a single string separated by
    spaces.  A default for this option can be put in a configuration file.
""",
        "module":"""
-m MODULESPEC
--module MODULESPEC
    Define a modulespec. If you specify modules with this option you don't have
    to put modulespecs after some of the commands.  You can specify more than
    one of these by repeating this option or by joining values in a single
    string separated by spaces. A default for this option can be put in a
    configuration file.
""",
        "exclude_states":"""
-X REGEXP
--exclude-states REGEXP
    For command 'try' exclude all 'dependents' whose state does match one of
    the regular expressions (REGEXP).
""",
        "brief":"""
-b
--brief
    Create a more brief output for some commands.
""",
        "detail":"""
--detail DETAIL
    Control the output of command 'try'. The value must be an integer between 0
    (very short) and 3 (very long).
""",
        "dir_patch":"""
-D PATCHEXPRESSION
--dir-patch PATCHEXPRESSION
    Specify a directory PATCHEXPRESSION. Such an expression consists of a tuple
    of 2 python strings.  The first is the match expression, the second one is
    the replacement string. The regular expression is applied to every source
    path generated. You can specify more than one PATCHEXPRESSION. A default
    for this option can be put in a configuration file.
""",
        "url_patch":"""
-U PATCHEXPRESSION
--url-patch PATCHEXPRESSION
    Specify a repository url PATCHEXPRESSION. Such an expression consists of a
    tuple of 2 python strings.  The first is the match expression, the second
    one is the replacement string. The regular expression is applied to every
    source url generated. You can specify more than one PATCHEXPRESSION. A
    default for this option can be put in a configuration file.
""",
        "noignorecase":"""
--noignorecase
    For command 'find', do NOT ignore case.
""",
        "no_checkout":"""
--no-checkout
    With this option, "new" does not check out sources of support modules. This
    option is only here for test purposes.
""",
        "no_make":"""
--no-make
    With this option, "new" does not call "make".
""",
        "makeflags":"""
--makeflags MAKEFLAGS
    Specify extra option strings for "make"You can specify more than one of
    these by repeating this option or by joining values in a single string
    separated by spaces.  A default for this option can be put in a
    configuration file.
""",
        "readonly":"""
--readonly
    Do not allow modifying the database files or the support directory. A
    default for this option can be put in a configuration file.
""",
        "nolock":"""
--nolock
    Do not use file locking.
""",
        "progress":"""
-p
--progress
    Show progress on stderr. A default for this option can be put in a
    configuration file.
""",
        "trace":"""
--trace
    Switch on some trace messages.
""",
        "tracemore":"""
--tracemore
    Switch on even more trace messages.
""",
        "dump_modules":"""
--dump-modules
    Dump module specs, then stop the program.
""",
        "list":"""
--list
    Show information for automatic command completion.
""",
        "yes":"""
-y
--yes
    All questions the program may ask are treated as if the user replied 'yes'.
""",
        "exceptions":"""
--exceptions
    On fatal errors that raise python exceptions, don't catch these. This will
    show a python stacktrace instead of an error message and may be useful for
    debugging the program.
""",
        "verbose":"""
-v
--verbose
    Show command calls. A default for this option can be put in a configuration
    file.
""",
        "version":"""
--version
    Show the program version and exit.
""",
        "dry_run":"""
-n
--dry-run
    Just show what the program would do.
"""
}

def print_option_help(option_list=None):
    """give help for a command line option.

    If option is empty, show help for all options.
    """
    lines= []
    if not option_list:
        for n in sorted(option_help_topics.keys()):
            lines.extend(option_help_topics[n].splitlines())
    else:
        for n in sorted(option_list):
            lines.extend(option_help_topics[n].splitlines())
    lines.append("")
    lineno= len(lines)
    txt= "\n".join(lines)
    if pager_mode=="on" or pager_mode=="always":
        if lineno>24 or pager_mode=="always":
            pydoc.pager(txt)
    print txt


me= script_shortname()
usage_help = """usage: %s maincommand [subcommand] [options]

Enter '%s help' for help on commands,
      '%s help listoptions' or 'sumo -h all' for a list of all options
      '%s -h option [option]' for help on the given options
""" % tuple([me]*4)

# pylint: enable=C0330
#                          Wrong indentation

def maincmd_help(arguments, options):
    """implement "help" command.
    """
    # pylint: disable=R0911
    #                          Too many return statements
    # pylint: disable=R0914
    #                          Too many local variables
    def main_topic_complete(topic_list, st, _):
        """completion for sub-topics."""
        return [k for k in topic_list if k.startswith(st)]
    def sub_topic_complete(sub_topic_dict, st, result):
        """completion for sub-topics."""
        s= sub_topic_dict.get(result.MAINTOPIC)
        if not s:
            return []
        return [k for k in s if k.startswith(st)]

    main_topics_list= [k for k in help_topics.keys() if " " not in k]
    sub_topics_list = [k for k in help_topics.keys() if " " in k]
    sub_topics= {}

    for s in sub_topics_list:
        (main_topic, sub_topic) = s.split()
        l= sub_topics.get(main_topic)
        if l is None:
            l= set()
            sub_topics[main_topic]= l
        l.add(sub_topic)

    argspec= sumolib.cli.CmdSpecs()
    argspec.add("MAINTOPIC", optional= True,
                completion= lambda s,r: \
                         main_topic_complete(main_topics_list, s, r))
    argspec.add("SUBTOPIC", optional= True,
                completion= lambda s,r: \
                         sub_topic_complete(sub_topics, s, r))
    args= sumolib.cli.process_args(arguments, argspec, options.list)

    # pylint: disable=no-member
    if not args.defined("MAINTOPIC"):
        helpkey= ""
    elif not args.defined("SUBTOPIC"):
        helpkey= args.MAINTOPIC
    else:
        helpkey= " ".join([args.MAINTOPIC, args.SUBTOPIC])

    if helpkey=="listoptions":
        # special handling of "listoptions" topic here:
        print_option_help()
        return

    txt= help_topics.get(helpkey)
    if txt is None:
        print "no help found for '%s'" % helpkey
        return
    if pager_mode=="on" or pager_mode=="always":
        lineno= len(txt.splitlines())
        if lineno>24 or pager_mode=="always":
            pydoc.pager(txt)
    print txt

# -----------------------------------------------
# program's main command processing function
# -----------------------------------------------

def process(options, commands):
    """do all the work.
    """
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0915
    #                          Too many statements
    # pylint: disable=R0911
    #                          Too many return statements
    global catch_exceptions
    if options.exceptions:
        catch_exceptions= False

    (cmd, c_args)= sumolib.cli.process_cmd(commands, KNOWN_MAIN_COMMANDS,
                                           options.list)

    if cmd=="help":
        maincmd_help(c_args, options)
        return

    if cmd=="config":
        maincmd_config(c_args, options)
        return

    # load config files and merge with options (options object is changed):
    (options, _)= load_config_files(options, None)
    # ^^ disable_loading==None means: use options.disable_loading

    # Set callbacks for completion module here, they are needed for some
    # command completion functions:
    if options.list:
        sumolib.complete.db_cache_callback= \
                lambda : db_to_module_cache(options)
        sumolib.complete.build_cache_callback= \
                lambda : builddb_to_module_cache(options)
    else:
        # clear possible cache files created by completion:
        sumolib.complete.clear_caches()

    if cmd=="lock":
        maincmd_lock(c_args, options)
        return
    elif cmd=="unlock":
        maincmd_unlock(c_args, options)
        return
    elif cmd=="db":
        maincmd_db(c_args, options)
    elif cmd=="build":
        maincmd_build(c_args, options)
    else:
        raise AssertionError("unexpected command: %s" % cmd)
    return

# -----------------------------------------------
# program's main function
# -----------------------------------------------

def main():
    """The main function.

    parse the command-line options and perform the command
    """
    # command-line options and command-line help:
    # pylint: disable=R0915
    #                          Too many statements

    specs= sumolib.cli.OptionSpecs()
    specs.completion_options("list", "--list", "--listnew")
    specs.add("--help -h")
    specs.add("--summary")
    specs.add("--test")
    specs.add("--config -c",
              sumolib.cli.complete_file,
              "CONFIGFILE",
              array= True)
    specs.add("--no-default-config -C")
    specs.add("--disable-loading")
    specs.add("--append -A",
              lambda s,o: \
                    sumolib.cli.complete_list(KNOWN_CONFIG_OPTIONS, s, o),
              arg_name= "optionname", array= True)
    specs.add("--#preload", sumolib.cli.complete_file, "FILES", array= True)
    specs.add("--#opt-preload", sumolib.cli.complete_file, "FILES", array= True)
    specs.add("--#postload", sumolib.cli.complete_file, "FILES", array= True)
    specs.add("--#opt-postload", sumolib.cli.complete_file, "FILES",
              array= True)
    specs.add("--dbdir", sumolib.cli.complete_dir, arg_name= "DBDIR")
    specs.add("--dbrepomode", arg_name= "MODE",
              value_list= KNOWN_REPO_MODES)
    specs.add("--dbrepo", arg_name= "REPOSITORY")
    specs.add("--scandb", sumolib.cli.complete_file, "SCANDB")
    specs.add("--dumpdb")
    specs.add("--logmsg", arg_name= "BUILDTAG")
    specs.add("--editor", arg_name= "EDITOR")
    specs.add("--buildtag -t", arg_name= "BUILDTAG")
    specs.add("--buildtag-stem", arg_name= "STEM")
    specs.add("--builddir", sumolib.cli.complete_dir, arg_name= "BUILDDIR")
    specs.add("--localbuilddir", sumolib.cli.complete_dir, arg_name= "BUILDDIR")
    specs.add("--output -o", arg_name= "OUTPUTFILE")
    specs.add("--extra -x", arg_name= "EXTRALINE", array= True)
    specs.add("--alias -a", arg_name= "ALIAS", array= True)
    specs.add("--module -m", arg_name= "MODULESPEC", array= True)
    specs.add("--exclude-states -X", arg_name= "REGEXP", array= True)
    specs.add("--brief -b")
    specs.add("--detail", arg_name= "DETAIL", value_list=["0","1","2","3"])
    specs.add("--dir-patch -D", arg_name= "PATCHEXPRESSION", array= True)
    specs.add("--url-patch -U", arg_name= "PATCHEXPRESSION", array= True)
    specs.add("--noignorecase")
    specs.add("--no-checkout")
    specs.add("--no-make")
    # with arg_is_option we allow the option argument to start with a "-":
    specs.add("--makeflags", arg_name= "MAKEFLAGS", array= True,
              arg_is_option= True)
    specs.add("--readonly")
    specs.add("--nolock")
    specs.add("--progress -p")
    specs.add("--trace")
    specs.add("--tracemore")
    specs.add("--dump-modules")
    specs.add("--list")
    specs.add("--yes -y")
    specs.add("--exceptions")
    specs.add("--verbose -v")
    specs.add("--version")
    specs.add("--dry-run -n")

    #x= sys.argv
    #tracemsg("%s\n" % repr(x))

    if len(sys.argv)<=1:
        print usage_help
        sys.exit(0)

    if len(sys.argv)<=2:
        if sys.argv[1]=="-h" or sys.argv[1]=="--help":
            print usage_help
            sys.exit(0)

    (options, args)= sumolib.cli.process_opts(sys.argv, specs)

    # pylint: disable=E1103
    #                          Instance of 'Options' has no .. member

    #sys.stderr.write("options object: %s" % options)

    if options.help:
        if not options.list:
            l= [x for x in options.defined_items() if x!="help"]
            print_option_help(l)
        sys.exit(0)
    if options.summary:
        if not options.list:
            print_summary()
        sys.exit(0)
    if options.version:
        print "%s %s" % (me, __version__)
        sys.exit(0)
    if options.test:
        if not options.list:
            _test()
        sys.exit(0)

    # pylint: enable=E1103
    #                          Instance of 'Options' has no .. member

    # options: the options-object
    # args: list of left-over args

    # join some of the list options:
    options.alias      = sumolib.utils.opt_join(options.alias, do_sort= True)
    options.module     = sumolib.utils.opt_join(options.module)
    options.makeflags   = sumolib.utils.opt_join(options.makeflags)

    # ^^^ A set of all options where lists from the command line are *appended*
    # to lists from the config file. The default is that lists from the command
    # line overwrite settings from the config file.
    if not options.append:
        options.append= set()
    else:
        options.append= sumolib.utils.opt_join(options.append)
        options.append= set(options.append)

    # we could pass "args" as an additional parameter to process here if it
    # would be needed to process remaining command line arguments.
    process(options, args)
    sys.exit(0)

if __name__ == "__main__":
    main()

