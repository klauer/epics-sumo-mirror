#! /usr/bin/env python
# -*- coding: UTF-8 -*-

# pylint: disable=C0301
#                          Line too long
"""
==========
sumo-db-py
==========

Create a JSON database with module and dependency information.

Logical definitions
-------------------

module:
    A module is a software package, usually an EPICS support module. Modules
    have a directory tree with the sources and are usually managed with a
    version control system. At the HZB we use darcs.  Each module has a unique
    *modulename*. The source of the module is available in several versions.
    The set of versions that have been tested are called the *moduleversions*.
    A single item of this set is called a *versionedmodule*.

versionedmodule:
    This is a named and tested version of a module. A versionedmodule has a
    *versionname* that is unique for that module, a *modulesource* and
    *dependencies*.

modulesource:
    This is the specification on how to obtain the module. The modulesource
    consists of a *sourcetype*, a *sourceurl* and an optional *sourcetag*.

dependencies:
    This is the specification of the dependencies of the versionedmodule. Each
    item is a *dependency*, consisting of a *modulename* and a *versionname*.
    Additionally, an *aliases* set defines alternative names for the dependency
    modules, these are needed for generation of configure/RELEASE files.

Datastructure
-------------

Some parts of the entities described above are used as keys in maps (python
dictionaries). In order to not to be confused with the definitions above we add
some more here.

dataset:
    This is the collection of all the module data, a map. In this map, each key
    is a *modulename* and the values are *moduleversions* entities.

modulename:
    The unique name of a module.

moduleversions:
    This is a map where each key is a *versionname* and each value is a
    *versiondata* item.

versiondata:
    This is a map that contains the information associated with the
    versionedmodile. The map keys are "source", the *modulesource* definition,
    "aliases", the alias map and "dependencies", the dependencies
    specification.

modulesource:
    This is the specification on how to obtain the module. It is a list of 2 to
    3 items. The first one is the *sourcetype*, the second one is the
    *sourceurl* and the optional third one is the *sourcetag*.

aliases:
    This is a map that contains optional alias names for modulenames in the
    dependency specification. These aliases may be needed for the generation of
    the configure/RELEASE files.

dependencies:
    This item contains the dependency specification for a module. It is a map
    where each key is a modulename and the value is a list of versionnames.


Example
-------

Here is an example of a dataset::

  {
      "ALARM": {
          "R3-5": {
              "dependencies": {
                  "MISC": [
                      "R2-4"
                  ],
                  "TIMER": [
                      "R5-1"
                  ]
              },
              "source": [
                  "darcs",
                  "/opt/repositories/controls/darcs/epics/support/alarm/base-3-14",
                  "R3-5"
              ]
          }
      },

      "MISC": {
          "R2-1": {
              "dependencies": {},
              "source": [
                  "darcs",
                  "/opt/repositories/controls/darcs/epics/support/misc/base-3-14",
                  "R2-1"
              ]
          },
          "R2-4": {
              "dependencies": {},
              "source": [
                  "darcs",
                  "/opt/repositories/controls/darcs/epics/support/misc/base-3-14",
                  "R2-4"
              ]
          }
      },
  }

"""
# pylint: enable=C0301

# pylint: disable=C0103
#                          Invalid name ... for type module
# pylint: disable=C0322
#                          Operator not preceded by a space

from optparse import OptionParser
import sys
import os.path
import os
import re

import sumo.utils as utils

# version of the program:
my_version= "1.1"

KNOWN_COMMANDS=set(("edit", "convert", "distribution",
                    "weight",
                    "show", "shownewest", "showall",
                    "find",
                    "merge", "check", "filter",
                    "cloneversion", "replaceversion"))

CONFIG_NAME="sumo-db.config"

# -----------------------------------------------
# main
# -----------------------------------------------

def script_shortname():
    """return the name of this script without a path component."""
    return os.path.basename(sys.argv[0])


def create_database(deps, repoinfo, groups, archs, state, source_patches):
    """join the information of the three sources.
    """
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0915
    #                          Too many statements
    # pylint: disable=R0913
    #                          Too many arguments
    def errmsg(msg):
        """print something on stderr."""
        sys.stderr.write(msg+"\n")

    try:
        state= utils.Builddb.guess_state(state)
    except ValueError, e:
        sys.exit(str(e))
    patcher= utils.RegexpPatcher()
    if source_patches:
        for p in source_patches:
            patcher.add(eval(p))
    _path2namevname= {}
    _namevname2path= {}
    db= utils.Dependencies()
    # we first create the map from modulenames to versiondata. In this loop we
    # populate the versiondata only with the source specification. We also
    # create two maps:
    #    _path2namevname: maps a diretory path to (module_name, versionname)
    #    _namevname2path: maps (module_name,versionname) to a diretory path
    for module_name, groupdata in groups.items():
        # the root directory of all the versions:
        for root_path, subdirs in groupdata.items():
            for subdir in sorted(subdirs):
                # iterate over all versions from <groups>:
                # reconstruct the original directory path:
                versionedmodule_path= os.path.join(root_path, subdir)
                # get the repository data:
                try:
                    (repotype, repodata)= repoinfo.get_data(
                                                   versionedmodule_path)
                    #(source_type, url, source_tag) = \
                    #    repoinfo.get(versionedmodule_path)
                except KeyError, _:
                    # shouldn't happen, but we just print a warning in this
                    # case:
                    errmsg("no source data: %s" % versionedmodule_path)
                    continue

                if repotype=="path":
                    # the source is a directory path, not a repository. We
                    # generate the unique versionname:
                    if subdir.startswith("PATH-"):
                        # Try to handle a subdir that was created by this set
                        # of tools. Such a subdir may already be named
                        # "PATH-<name>+<treetag>". We want to take <name> as
                        # versionname in this case:
                        versionname= utils.split_treetag(subdir)[0]
                    else:
                        versionname= "PATH-%s" % subdir
                    # repodata is just the path in this case:
                    repodata= patcher.apply(repodata)
                elif repotype=="darcs":
                    if not repodata.has_key("tag"):
                        # the source is a darcs repository but has no tag. We
                        # generate a unique versionname:
                        if subdir.startswith("TAGLESS-"):
                            # Try to handle a subdir that was created by this
                            # set of tools. Such a subdir may already be named
                            # "PATH-<name>+<treetag>". We want to take <name>
                            # as versionname in this case:
                            versionname= utils.split_treetag(subdir)[0]
                        else:
                            versionname= "TAGLESS-%s" % subdir
                        # patch URL to <versionedmodule_path>. Since we do not
                        # know in what state the working copy repository is, we
                        # have to take this as a source instead of the central
                        # repository:
                        repodata= {"url": patcher.apply(versionedmodule_path)}
                    else:
                        # make a copy of repodata so we can modify it:
                        repodata= dict(repodata)
                        repodata["url"]= patcher.apply(repodata["url"])
                        # the source is a darcs repository with a tag. We use
                        # the tag as unique versionname:
                        versionname= repodata["tag"]
                module_archs= archs.get(versionedmodule_path, [])
                if not module_archs:
                    #  module_archs list is empty:
                    errmsg("no archs for path %s" % \
                           versionedmodule_path)
                db.set_source(module_name, versionname, module_archs, state,
                              {repotype: repodata})

                _path2namevname[versionedmodule_path]= \
                        (module_name,versionname)
                # when we assume that a versionedmodule_path may contain a
                # buildtag, there may be several versionedmodule_paths for a
                # pair of (module_name, versionname).
                _paths= _namevname2path.setdefault(
                                    (module_name, versionname),[])
                _paths.append(versionedmodule_path)

    #utils.json_dump(_path2namevname)
    #sys.exit(0)

    # here we populate the versiondata with the dependency specifications:
    for modulename in db.iter_modulenames():
        # loop on stable, testing and unstable versions:
        for versionname in db.iter_versions(modulename, "unstable",
                                            None, False):
            versionedmodule_paths= _namevname2path[(modulename, versionname)]

            for versionedmodule_path in versionedmodule_paths:
                _deps= deps.get(versionedmodule_path)
                if _deps is None:
                    errmsg("no dependency info for path %s" % \
                           versionedmodule_path)
                    continue
                for alias, dep_path in _deps.items():
                    try:
                        (_dep_name, _dep_version)= _path2namevname[dep_path]
                    except KeyError, _:
                        sys.exit(("at module %s version %s "+ \
                                  "path %s: "+ \
                                  "missing data for "+ \
                                  "dependency \"%s\"") % \
                                  (modulename, versionname,
                                   versionedmodule_path,
                                   dep_path))
                    if _dep_name != alias:
                        try:
                            db.add_alias(modulename, versionname,
                                         alias, _dep_name)
                        except ValueError, e:
                            errmsg("alias error in module %s: %s" % \
                                   (modulename, str(e)))
                    db.add_dependency(modulename, versionname,
                                      _dep_name, _dep_version, state)
    return db

def _distribution_add(db, dist, modulename, versionname, maxstate, archs):
    """add a module to the set."""
    # pylint: disable=R0913
    #                          Too many arguments
    #print "_distribution_add(..,..,",modulename,",",versionname,")"
    existing_versionname= dist.get(modulename)
    if existing_versionname is not None:
        if existing_versionname!= versionname:
            raise ValueError("conflict: %s %s %s" % \
                      (modulename, existing_versionname, versionname))
        return dist
    if not db.check_archs(modulename, versionname, archs):
        raise ValueError("no support for archs %s in module %s:%s" % \
                         (repr(archs),modulename,versionname))
    new_dist= dict(dist)
    # ^^^ caution, not a deep copy
    new_dist[modulename]= versionname
    try:
        if not db.dependencies_found(modulename, versionname):
            return new_dist
    except KeyError, e:
        sys.exit("no information for module %s version %s" % \
                 (modulename, versionname))

    for dep_modulename in db.iter_dependencies(modulename, versionname):
        for dep_version in db.sorted_dependency_versions(
                modulename, versionname, dep_modulename, maxstate, archs):
            errst= None
            try:
                new_dist= _distribution_add(db,
                                            new_dist,
                                            dep_modulename,
                                            dep_version, maxstate, archs)
                errst= None
                break
            except ValueError, e:
                errst= str(e)
        if errst:
            raise ValueError("no module found, last error message: %s" % \
                             errst)
    return new_dist

def distribution(db, modulespec_list, maxstate, archs, trace):
    """create a distribution.
    """
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    if trace:
        sys.stderr.write("looking for modules, archs: %s maxstate: %s\n\n" % \
                         (repr(archs), maxstate))

    versioned_modules= []
    versionless_modules= []
    for m in modulespec_list:
        (modulename, modulespec)= utils.scan_module_arch_spec(m, archs)
        versionname= modulespec.get("version")
        if not versionname:
            versionless_modules.append((modulename, modulespec.get("archs")))
        elif modulespec["version_flag"]=="==":
            versioned_modules.append((modulename, versionname,
                                      modulespec.get("archs")))
        else:
            raise ValueError("\"-version\" and \"+version\" not "
                             "supported here")
    dist= {}
    for (modulename, versionname, archs) in versioned_modules:
        try:
            dist= _distribution_add(db, dist, modulename, versionname,
                                    maxstate, archs)
        except ValueError, e:
            sys.exit(str(e))

    for (modulename, archs) in versionless_modules:
        if trace:
            sys.stderr.write("module %s\n" % modulename)
        try:
            versionlist= db.sorted_moduleversions(modulename, maxstate,
                                                  archs, True)
        except KeyError, e:
            sys.exit("no data for module %s" % modulename)
        except ValueError, e:
            sys.exit("Error: %s" % str(e))

        found= False
        for versionname in versionlist:
            try:
                dist= _distribution_add(db, dist, modulename, versionname,
                                        maxstate, archs)
                found= True
                break
            except ValueError, e:
                if trace:
                    sys.stderr.write("\t%-15s: %s\n" % \
                                     (versionname, str(e)))
        if not found:
            sys.exit("no non conflicting versions found for %s" % modulename)
        else:
            if trace:
                sys.stderr.write("\t%-15s --> found\n" % versionname)

    spec_dict= {}
    for (m,v) in dist.items():
        spec_dict[m]= {"version":v, "version_flag":"=="}
    new= db.partial_copy_by_specdict(spec_dict)
    new.remove_missing_deps()
    return (dist,new)

def set_weight(db, weight, modulespeclist, trace):
    """set the weight for one or more modules."""
    for m in modulespeclist:
        (modulename, modulespec)= utils.scan_module_arch_spec(m)
        if trace:
            sys.stderr.write("module %s, spec: %s\n" % \
                             (modulename, modulespec))

        versionname= modulespec.get("version")
        versionflag= modulespec.get("version_flag")

        # scan stable, testing and unstable versions:
        for version in db.iter_versions(modulename, "unstable",
                                        None, must_exist= False):
            if trace:
                sys.stderr.write("test %s:%s\n" % (modulename,version))
            if not utils.compare_versions_flag(versionflag,version,
                                               versionname):
                continue
            if trace:
                sys.stderr.write("set weight %d on %s:%s\n" % \
                                 (weight,modulename,version))
            db.weight(modulename, version, weight)

def process(options, commands):
    """do all the work.
    """
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0911
    #                          Too many return statements
    # pylint: disable=R0915
    #                          Too many statements
    if options.nolock:
        utils.use_lockfile= False
    if not commands:
        sys.exit("command missing")
    if commands[0] not in KNOWN_COMMANDS:
        sys.exit("unknown command: %s" % commands[0])

    if commands[0]=="edit":
        if len(commands)!=2:
            sys.exit("exactly one filename must follow \"edit\"")
        utils.edit_with_lock(commands[1], options.verbose, options.dry_run)
        return

    if commands[0]=="convert":
        if len(commands)!=3:
            sys.exit("a state and a filename must follow \"convert\"")
        (state, filename)= commands[1:]
        scandata= utils.json_loadfile(filename)
        deps= scandata["dependencies"]
        repoinfo= utils.PathSource(scandata["repos"])
        groups= scandata["groups"]
        archs= scandata["archs"]
        db= create_database(deps, repoinfo, groups, archs, state,
                            options.source_patch)
        db.json_print()
        return

    if commands[0]=="distribution":
        if len(commands)<=1:
            sys.exit("error: MAXSTATE missing")
        if len(commands)>2:
            modulespecs= commands[2:]
        else:
            # no modulespecs after the command
            modulespecs= options.module
            if not modulespecs:
                sys.exit("error: module specs missing")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= utils.Dependencies.from_json_file(options.db)
        maxstate= commands[1]
        (dist_dict, dist_obj)= distribution(db, modulespecs,
                                            maxstate, options.arch,
                                            options.trace)
        if options.brief:
            utils.json_dump(dist_dict)
        else:
            dist_obj.json_print()
        return

    if commands[0]=="weight":
        if len(commands)<=1:
            sys.exit("error: WEIGHT and module missing")
        if len(commands)<=2:
            sys.exit("error: no modules specified")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        weight= commands[1]
        modulespecs= commands[2:]
        try:
            weight= int(weight)
        except ValueError, _:
            sys.exit("error: weight must be an integer")
        db= utils.Dependencies.from_json_file(options.db,
                keep_locked= options.savedb and (not options.dry_run))
        set_weight(db, weight, modulespecs, options.trace)
        if options.savedb:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        else:
            db.json_print()
        return

    if commands[0]=="filter":
        if len(commands)>1:
            modulespecs= commands[1:]
        else:
            # no modulespecs after the command
            modulespecs= options.module
            if not modulespecs:
                sys.exit("error: module specs missing")

        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= utils.Dependencies.from_json_file(options.db,
                keep_locked= options.savedb and (not options.dry_run))
        db= db.partial_copy_by_specstrings(modulespecs, options.arch)
        if options.savedb:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        else:
            db.json_print()
        return

    if commands[0]=="check":
        if len(commands)>1:
            sys.exit("error: extra arguments following \"check\"")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db = utils.Dependencies.from_json_file(options.db,
                                               keep_locked= False)
        msg= db.check()
        print "\n".join(msg)
        return

    if commands[0]=="merge":
        if len(commands)!=2:
            sys.exit("exactly one filename must follow \"merge\"")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db = utils.Dependencies.from_json_file(options.db,
                keep_locked= options.savedb and (not options.dry_run))
        db2= utils.Dependencies.from_json_file(commands[1])
        db.merge(db2)
        if options.savedb:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        else:
            db.json_print()
        return

    if commands[0]=="cloneversion" or commands[0]=="replaceversion":
        do_replace= (commands[0]=="replaceversion")
        if len(commands)!=4:
            sys.exit("exactly three arguments must follow \"%s\"" % \
                     commands[0])
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db = utils.Dependencies.from_json_file(options.db,
                keep_locked= options.savedb and (not options.dry_run))
        db.patch_version(commands[1], commands[2], commands[3], do_replace)
        if options.savedb:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        else:
            db.json_print()
        return

    if commands[0]=="show":
        if len(commands)>1:
            sys.exit("error: extra arguments following \"show\"")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= utils.Dependencies.from_json_file(options.db)
        result= sorted(db.iter_modulenames())
        utils.json_dump(result)
        return

    if commands[0]=="shownewest" or commands[0]=="showall":
        showall= (commands[0]=="showall")
        if len(commands)<=1:
            sys.exit("error: MAXSTATE missing")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= utils.Dependencies.from_json_file(options.db)

        if len(commands)>2:
            modulespecs= commands[2:]
        else:
            # no modulespecs after the command
            modulespecs= options.module
            if not modulespecs:
                modulespecs= list(db.iter_modulenames())

        maxstate= commands[1]
        result= {}

        for spec in modulespecs:
            (modulename,spec_dict)= utils.scan_module_arch_spec(spec)
            match_version= spec_dict.get("version")
            match_flag   = spec_dict.get("version_flag")

            versions= db.sorted_moduleversions(modulename, maxstate,
                                               options.arch, False)
            if not versions: # no versions match maxstate criteria
                continue
            versions= [v for v in versions \
                       if utils.compare_versions_flag(match_flag,v,
                                                      match_version)]

            if not showall:
                result[modulename]= versions[0]
            else:
                result[modulename]= versions
        utils.json_dump(result)
        return

    if commands[0]=="find":
        if len(commands)<=1:
            sys.exit("error: MAXSTATE missing")
        if len(commands)<=2:
            sys.exit("error: REGEXP missing")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= utils.Dependencies.from_json_file(options.db)
        maxstate= commands[1]
        regexp= commands[2]
        if options.noignorecase:
            rx_flags= 0
        else:
            rx_flags= re.IGNORECASE
        rx= re.compile(regexp, rx_flags)
        results= db.search_modules(rx, maxstate, options.arch)
        if options.brief:
            for (module,version) in results:
                print "%s:%s" % (module,version)
            return
        newdb= db.partial_copy_by_list(results)
        newdb.json_print()
        return

def print_doc():
    """print a short summary of the scripts function."""
    print __doc__

def print_summary():
    """print a short summary of the scripts function."""
    print "%-20s: a tool for managing support EPICS trees \n" % \
          script_shortname()

def _test():
    """does a self-test of some functions defined here."""
    print "performing self test..."
    import doctest
    doctest.testmod()
    print "done!"

usage = """usage: %prog [options] command
where command is:
  edit [FILE]
          Start the editor specified by the environment variable "VISUAL" or
          "EDITOR" with that file. This command first aquires a file-lock on
          the file that is only released when the editor program is terminated.
          If you want to edit a DB or BUILDDB file directly, you should always
          do this with this command. The file locking prevents other users to
          use the file at the same time you modify it.
  convert [STATE] [SCANFILE]: 
          Convert SCANFILE to a new DB. All dependencies are marked with state
          STATE. STATE may be "stable", "testing" or "unstable".
  distribution [MAXSTATE] [modules]: 
          Create distribution from DB where all specified modules are
          contained. If you want a specific version of a module use
          modulename:versioname instead of the modulename alone. MAXSTATE is
          the "maximum" state of dependencies that are taken into account:
              stable:   take only dependencies marked stable
              testing:  take dependencies marked stable or testing
              unstable: take dependencies marked stable, testing or unstable
  weight [WEIGHT] [modules]
          Set the weight factor for modules. Use
          modulename:{+-}versionname to select more versions of a module.
          This command *does not* use the --modules option.
          Weight must be an integer.
  show:   show the names of all modules
  shownewest [MAXSTATE] {modules}: 
          Show newest version for each module. If {modules} is missing, take
          all modules of the database. MAXSTATE is the "maximum" state as
          described above.
  showall [MAXSTATE] {modules}: 
          Show all versions for each module. If {modules} is missing, take all
          modules of the database. MAXSTATE is the "maximum" state as described
          above.
  find [MAXSTATE] [REGEXP]
          Show all modules whose names or sources match regexp.
  check 
          do some consistency checks on the db specifed by --db
  merge [db]
          Merge the given db with the one specified by --db
  filter [modules]
          Print the database for the given modules. If you want a specific
          version of a module use modulename:versioname instead of the
          modulename alone.
  cloneversion [module old-version new-version]
          Add a new version to the database by copying the old version. The
          old-version data is copied for the new version data. All modules that
          depend on module:old-version now alternatively depend on
          module:new-version.
  replaceversion [module old-version new-version]
          Replace a version to the database with a new one. The old-version
          data is copied for the new version data. All modules that depend on
          module:old-version now depend on module:new-version.
"""

def main():
    """The main function.

    parse the command-line options and perform the command
    """
    # command-line options and command-line help:

    parser = OptionParser(usage=usage,
                          version="%%prog %s" % my_version,
                          description="This program manages EPICS support trees"
                         )

    parser.add_option("--summary",
                      action="store_true",
                      help="Print a summary of the function of the program.",
                      )
    parser.add_option("--doc",
                      action="store_true",
                      help="Print a longer description of the program.",
                      )
    parser.add_option("--test",
                      action="store_true",
                      help="Perform simple self-test.",
                      )
    parser.add_option("-c", "--config",
                      action="store",
                      type="string",
                      help="Load options from config file FILE, "
                           "default: %s." % CONFIG_NAME,
                      metavar="FILE"
                      )
    parser.add_option("--make-config",
                      action="store",
                      type="string",
                      help="Create a new config file FILE from the given "
                           "options. If the filename is '-' dump "
                           "to the console, if it is an empty string, "
                           "rewrite the config file that was read before.",
                      metavar="FILE"
                      )
    parser.add_option("--db",
                      action="store",
                      type="string",
                      help="Define the name of the DBFILE. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="DBFILE"
                      )
    parser.add_option("--savedb",
                      action="store_true",
                      help="Resave db if it was modified, currently "
                           "only for these commands : %s." % \
                           (" ".join(("merge","filter",
                                      "cloneversion", "replaceversion")))
                      )
    parser.add_option("--arch",
                      action="append",
                      help="Define the name of a TARGETARCHITECTURE. You "
                           "can specify more than one target architecture."
                           "You can specify more than one of these by "
                           "repeating this option or by joining values in "
                           "a single string separated by spaces. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="TARGETARCHITECTURE"
                      )
    parser.add_option("-m", "--module",
                      action="append",
                      help="Define a MODULESPEC. A MODULESPEC has the form "
                           "modulename, modulename:version, "
                           "modulename:-version or modulename:+version. If "
                           "you specify modules with this option you don't "
                           "have to put MODULESPECs after commands like "
                           "'find' or 'use'. "
                           "You can specify more than one of these by "
                           "repeating this option or by joining values in "
                           "a single string separated by spaces. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="MODULESPEC"
                      )
    parser.add_option("-b", "--brief",
                      action="store_true",
                      help="Create a more brief output. ",
                      )
    parser.add_option("-P", "--source-patch",
                      action="append",
                      help="Specify a source PATCHEXPRESSION. Such an "
                           "expression consists of a tuple of 2 python "
                           "strings. The first is the match expression, "
                           "the second one is the replacement string. The "
                           "regular expression is applied to every source "
                           "url generated. You can specify more than one "
                           "PATCHEXPRESSION. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="PATCHEXPRESSION"
                      )
    parser.add_option("--noignorecase",
                      action="store_true",
                      help="For command 'find', do NOT ignore case.",
                      )
    parser.add_option("--nolock",
                      action="store_true",
                      help="Do not use file locking."
                      )
    parser.add_option("-p", "--progress",
                      action="store_true",
                      help="Show progress on stderr. "
                           "This option value is stored in the CONFIGFILE.",
                      )
    parser.add_option("-t", "--trace",
                      action="store_true",
                      help="Switch on some trace messages.",
                      )
    parser.add_option("-v", "--verbose",
                      action="store_true",
                      help="Show command calls. "
                           "This option value is stored in the CONFIGFILE.",
                      )
    parser.add_option("-n", "--dry-run",
                      action="store_true",
                      help="Just show what the program would do.",
                      )

    # x= sys.argv
    (options, args) = parser.parse_args()
    # options: the options-object
    # args: list of left-over args

    # join some of the list options:
    options.arch  = utils.opt_join(options.arch, do_sort= True)
    options.module= utils.opt_join(options.module)

    config= utils.ConfigFile(( "arch", "db",
                               "module",
                               "progress", "source_patch",
                               "verbose"), CONFIG_NAME)

    if options.summary:
        print_summary()
        sys.exit(0)

    if options.doc:
        print_doc()
        sys.exit(0)

    if options.test:
        _test()
        sys.exit(0)

    config.load_file(options.config)
    # Note: options that are "None" are not changed in the config object:
    config.update_from_options(options)
    config.fill_options(options, overwrite= False)

    if options.make_config is not None:
        config.save_file(options.make_config)
        sys.exit(0)

    # we could pass "args" as an additional parameter to process here if it
    # would be needed to process remaining command line arguments.
    process(options, args)
    sys.exit(0)

if __name__ == "__main__":
    main()


