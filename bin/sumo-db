#! /usr/bin/env python
# -*- coding: UTF-8 -*-

# pylint: disable=C0111
#                          Missing docstring
# pylint: disable=C0301
#                          Line too long
# pylint: enable=C0301

# pylint: disable=C0103
#                          Invalid name ... for type module
# pylint: disable=C0322
#                          Operator not preceded by a space

from optparse import OptionParser
import sys
import os.path
import os
import re
import copy

import sumo.lock
import sumo.JSON
import sumo.utils as utils
import sumo.Config
import sumo.ModuleSpec
import sumo.Databases

# version of the program:
my_version= "1.7.3" #VERSION#

sumo.lock.assert_version(my_version)
sumo.JSON.assert_version(my_version)
utils.assert_version(my_version)

KNOWN_COMMANDS=set(("alias-add", "appconvert", "check", "clonemodule",
                    "cloneversion", "convert", "edit", "filter", "find",
                    "list", "makeconfig", "merge", "dependency-add",
                    "dependency-delete", "replaceversion", "showall",
                    "shownewest", "state", "weight"))

CONFIG_NAME="sumo-db.config"

# -----------------------------------------------
# utils
# -----------------------------------------------

def script_shortname():
    """return the name of this script without a path component."""
    return os.path.basename(sys.argv[0])

# -----------------------------------------------
# load JSON files
# -----------------------------------------------

def db_from_json_file(filename, keep_locked= False):
    """load a db, exits gracefully in case of an error."""
    try:
        db= sumo.Databases.Dependencies.from_json_file(filename, keep_locked)
    except ValueError, e:
        sys.exit("Error while loading builddb,\n%s" % str(e))
    except IOError, e:
        sys.exit("Error while loading builddb,\n%s" % str(e))
    return db

# -----------------------------------------------
# main
# -----------------------------------------------

def create_app_data(deps, repoinfo, groups):
    """create configuration data for an app."""
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    def errmsg(msg):
        """print something on stderr."""
        sys.stderr.write(msg+"\n")
    keys= deps.keys()
    if len(keys)!=1:
        sys.exit("error: \"dependencies\" map must have exactly one key")

    modulespecs= []
    aliases    = []

    app_path= keys[0]
    specs_by_path= {}

    for module_name, groupdata in groups.items():
        keys= groupdata.keys()
        if len(keys)!=1:
            sys.exit("error: groupdata \"%s\" must have exactly one key" % \
                     module_name)
        root_path= keys[0]
        values= groupdata[root_path]
        if len(values)!=1:
            sys.exit("error: groudata \"%s\" must have exactly one "
                     "subdir" % module_name)
        subdir= values[0]
        versionedmodule_path= os.path.join(root_path, subdir)
        try:
            (repotype, repodata)= repoinfo.get_data(
                                           versionedmodule_path)
        except KeyError, _:
            # shouldn't happen, but we just print a warning in this
            # case:
            errmsg("no source data: %s" % versionedmodule_path)
            continue
        if repotype=="path":
            versionname= "PATH-%s" % subdir
        elif repotype=="darcs":
            if not repodata.has_key("tag"):
                versionname= "TAGLESS-%s" % subdir
            else:
                versionname= repodata["tag"]
        else:
            raise AssertionError("unknown repotype: "+repotype)
        specs_by_path[versionedmodule_path]= (module_name,versionname)

    for (aliasname, path) in deps[app_path].items():
        (module_name,versionname)= specs_by_path[path]
        modulespecs.append("%s:%s" % (module_name,versionname))
        if aliasname!=module_name:
            aliases.append("%s:%s" % (module_name, aliasname))
    aliases.sort()
    modulespecs.sort()

    return {"alias": aliases, "module": modulespecs}


def create_database(deps, repoinfo, groups, archs, state, source_patches):
    """join the information of the three sources.
    """
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0915
    #                          Too many statements
    # pylint: disable=R0913
    #                          Too many arguments
    def errmsg(msg):
        """print something on stderr."""
        sys.stderr.write(msg+"\n")

    try:
        sumo.Databases.Dependencies.check_state(state)
    except ValueError, e:
        sys.exit(str(e))
    patcher= utils.RegexpPatcher()
    if source_patches:
        for p in source_patches:
            patcher.add(eval(p))
    _path2namevname= {}
    _namevname2path= {}
    db= sumo.Databases.Dependencies()
    # we first create the map from modulenames to versiondata. In this loop we
    # populate the versiondata only with the source specification. We also
    # create two maps:
    #    _path2namevname: maps a diretory path to (module_name, versionname)
    #    _namevname2path: maps (module_name,versionname) to a diretory path
    for module_name, groupdata in groups.items():
        # the root directory of all the versions:
        for root_path, subdirs in groupdata.items():
            for subdir in sorted(subdirs):
                # iterate over all versions from <groups>:
                # reconstruct the original directory path:
                versionedmodule_path= os.path.join(root_path, subdir)
                # get the repository data:
                try:
                    (repotype, repodata)= repoinfo.get_data(
                                                   versionedmodule_path)
                except KeyError, _:
                    # shouldn't happen, but we just print a warning in this
                    # case:
                    errmsg("no source data: %s" % versionedmodule_path)
                    continue

                if repotype=="path":
                    # the source is a directory path, not a repository. We
                    # generate the unique versionname:
                    if subdir.startswith("PATH-"):
                        # Try to handle a subdir that was created by this set
                        # of tools. Such a subdir may already be named
                        # "PATH-<name>+<treetag>". We want to take <name> as
                        # versionname in this case:
                        versionname= utils.split_treetag(subdir)[0]
                    else:
                        versionname= "PATH-%s" % subdir
                    # repodata is just the path in this case:
                    repodata= patcher.apply(repodata)
                elif repotype=="darcs":
                    if not repodata.has_key("tag"):
                        # the source is a darcs repository but has no tag. We
                        # generate a unique versionname:
                        if subdir.startswith("TAGLESS-"):
                            # Try to handle a subdir that was created by this
                            # set of tools. Such a subdir may already be named
                            # "PATH-<name>+<treetag>". We want to take <name>
                            # as versionname in this case:
                            versionname= utils.split_treetag(subdir)[0]
                        else:
                            versionname= "TAGLESS-%s" % subdir
                        # patch URL to <versionedmodule_path>. Since we do not
                        # know in what state the working copy repository is, we
                        # have to take this as a source instead of the central
                        # repository:
                        repodata= {"url": patcher.apply(versionedmodule_path)}
                    else:
                        # make a copy of repodata so we can modify it:
                        repodata= dict(repodata)
                        repodata["url"]= patcher.apply(repodata["url"])
                        # the source is a darcs repository with a tag. We use
                        # the tag as unique versionname:
                        versionname= repodata["tag"]
                module_archs= archs.get(versionedmodule_path, [])
                if not module_archs:
                    #  module_archs list is empty:
                    errmsg("no archs for path %s" % \
                           versionedmodule_path)
                db.set_source_arch_state(module_name, versionname,
                                         module_archs, state,
                                         {repotype: repodata})

                _path2namevname[versionedmodule_path]= \
                        (module_name,versionname)
                # when we assume that a versionedmodule_path may contain a
                # buildtag, there may be several versionedmodule_paths for a
                # pair of (module_name, versionname).
                _paths= _namevname2path.setdefault(
                                    (module_name, versionname),[])
                _paths.append(versionedmodule_path)

    #sumo.JSON.dump(_path2namevname)
    #sys.exit(0)

    # here we populate the versiondata with the dependency specifications:
    for modulename in db.iter_modulenames():
        # loop on stable, testing and unstable versions:
        for versionname in db.iter_versions(modulename, "unstable",
                                            None, False):
            versionedmodule_paths= _namevname2path[(modulename, versionname)]

            for versionedmodule_path in versionedmodule_paths:
                _deps= deps.get(versionedmodule_path)
                if _deps is None:
                    errmsg("no dependency info for path %s" % \
                           versionedmodule_path)
                    continue
                for alias, dep_path in _deps.items():
                    try:
                        (_dep_name, _dep_version)= _path2namevname[dep_path]
                    except KeyError, _:
                        sys.exit(("at module %s version %s "+ \
                                  "path %s: "+ \
                                  "missing data for "+ \
                                  "dependency \"%s\"") % \
                                  (modulename, versionname,
                                   versionedmodule_path,
                                   dep_path))
                    if _dep_name != alias:
                        try:
                            db.add_alias(modulename, versionname,
                                         alias, _dep_name)
                        except ValueError, e:
                            errmsg("alias error in module %s: %s" % \
                                   (modulename, str(e)))
                    db.add_dependency(modulename, versionname,
                                      _dep_name, _dep_version, state)
    return db

def set_state(db, state, modulespecs):
    """set the state for modules and dependencies."""
    for modulespec in modulespecs:
        if not modulespec.is_exact_spec():
            # should also unlock the db:
            sys.exit("error: modulespec '%s' is not an exact "
                     "modulespec\n" % modulespec.to_string())

    # due to the remove_missing_deps() command later on, we have to ensure that
    # the partialdb is a deep copy:
    partialdb= copy.deepcopy(db.partial_copy_by_modulespecs(modulespecs))
    # remove dependencies that are not part of the partialdb:
    partialdb.remove_missing_deps()
    # this sets the states of modules and dependencies to the new value:
    db.merge(partialdb,
             constant_src_state=state,
             state_sum_mode= sumo.Databases.Dependencies.SUM_FIRST)

def set_weight(db, weight, modulespecs, trace):
    """set the weight for one or more modules."""
    for modulespec in modulespecs:
        modulename= modulespec.modulename
        if trace:
            sys.stderr.write("%s\n" % modulespec.to_string())

        # scan stable, testing and unstable versions:
        for version in db.iter_versions(modulename, "unstable",
                                        None, must_exist= False):
            if trace:
                sys.stderr.write("test %s:%s\n" % (modulename,version))
            if not modulespec.test(version):
                continue
            if trace:
                sys.stderr.write("set weight %d on %s:%s\n" % \
                                 (weight,modulename,version))
            db.weight(modulename, version, weight)

def dump_modules(modulespecs):
    """dump module specs.
    """
    for modulespec in modulespecs:
        print modulespec.to_string()

def process(options, commands):
    """do all the work.
    """
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0911
    #                          Too many return statements
    # pylint: disable=R0915
    #                          Too many statements

    config= sumo.Config.ConfigFile.from_optionlist(
                CONFIG_NAME,
                ( "#include",
                  "arch", "db", "maxstate", "module", "progress",
                  "source_patch", "verbose"))
    if (not os.path.exists(CONFIG_NAME)) or options.no_default_config:
        config.disable_default()

    try:
        config.load(options.config)
    except ValueError, e:
        sys.exit("Error while loading config file,\n%s" % str(e))
    except IOError, e:
        sys.exit("Error while loading config file,\n%s" % str(e))
    config.merge_options(options)

    if options.nolock:
        sumo.lock.use_lockfile= False
    if not commands:
        sys.exit("command missing")
    if commands[0] not in KNOWN_COMMANDS:
        sys.exit("unknown command: %s" % commands[0])

    if commands[0]=="makeconfig":
        if len(commands)>2:
            sys.exit("error: extra arguments following \"makeconfig\"")
        if len(commands)<=1:
            configfile= None
        else:
            configfile= commands[1]
        config.save(configfile)
        return

    if commands[0]=="edit":
        if len(commands)!=2:
            sys.exit("exactly one filename must follow \"edit\"")
        sumo.lock.edit_with_lock(commands[1], options.verbose, options.dry_run)
        return

    if commands[0]=="convert":
        if len(commands)!=3:
            sys.exit("a state and a filename must follow \"convert\"")
        (state, filename)= commands[1:]
        scandata= sumo.JSON.loadfile(filename)
        deps= scandata["dependencies"]
        repoinfo= utils.PathSource(scandata["repos"])
        groups= scandata["groups"]
        archs= scandata["archs"]
        db= create_database(deps, repoinfo, groups, archs, state,
                            options.source_patch)
        db.json_print()
        return

    if commands[0]=="appconvert":
        if len(commands)!=2:
            sys.exit("a filename must follow \"convert\"")
        filename= commands[1]
        scandata= sumo.JSON.loadfile(filename)
        deps= scandata["dependencies"]
        repoinfo= utils.PathSource(scandata["repos"])
        groups= scandata["groups"]
        struc= create_app_data(deps, repoinfo, groups)
        sumo.JSON.dump(struc)
        return

    if commands[0]=="weight":
        if len(commands)<=1:
            sys.exit("error: WEIGHT and module missing")
        if len(commands)<=2:
            sys.exit("error: no modules specified")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        weight= commands[1]
        modulespecs= commands[2:]
        try:
            weight= int(weight)
        except ValueError, _:
            sys.exit("error: weight must be an integer")
        db= db_from_json_file(options.db,
                keep_locked= not options.dumpdb and (not options.dry_run))
        try:
            modulespecs_obj= sumo.ModuleSpec.Specs.from_strings(modulespecs,
                                                                None)
        except ValueError, e:
            sys.exit(str(e))

        if options.dump_modules:
            dump_modules(modulespecs_obj)
            sys.exit(0)
        set_weight(db, weight, modulespecs_obj, options.trace)
        if options.dumpdb:
            db.json_print()
        else:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="filter":
        modulespecs= []
        if options.module:
            modulespecs.extend(options.module)
        if len(commands)>1:
            modulespecs.extend(commands[1:])
        if not modulespecs:
            sys.exit("error: module specs missing")

        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= db_from_json_file(options.db, keep_locked= False)
        try:
            modulespecs_obj= sumo.ModuleSpec.Specs.from_strings(modulespecs,
                                                            options.arch)
        except ValueError, e:
            sys.exit(str(e))

        if options.dump_modules:
            dump_modules(modulespecs_obj)
            sys.exit(0)
        db= db.partial_copy_by_modulespecs(modulespecs_obj)
        db.json_print()
        return

    if commands[0]=="check":
        if len(commands)>1:
            sys.exit("error: extra arguments following \"check\"")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db = db_from_json_file(options.db,
                                               keep_locked= False)
        msg= db.check()
        print "\n".join(msg)
        return

    if commands[0]=="merge":
        if len(commands)!=2:
            sys.exit("exactly one filename must follow \"merge\"")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db = db_from_json_file(options.db,
                keep_locked= not options.dumpdb and (not options.dry_run))
        db2= db_from_json_file(commands[1])
        db.merge(db2, constant_src_state= None,
                 state_sum_mode= sumo.Databases.Dependencies.SUM_MIN)
        if options.dumpdb:
            db.json_print()
        else:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="alias-add":
        if len(commands)<4:
            sys.exit("Three arguments must follow \"%s\"" % \
                     commands[0])
        if not options.db:
            sys.exit("error, --db is mandatory here")
        module_spec= sumo.ModuleSpec.Spec.from_string(commands[1])
        (depname,alias)= commands[2:4]
        db = db_from_json_file(options.db,
                keep_locked= not options.dumpdb and (not options.dry_run))
        db.add_alias(module_spec.modulename,
                     module_spec.versionname,
                     alias, depname)
        if options.dumpdb:
            db.json_print()
        else:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="dependency-add":
        if len(commands)<4:
            sys.exit("Three arguments must follow \"%s\"" % \
                     commands[0])
        if not options.db:
            sys.exit("error, --db is mandatory here")
        module_spec= sumo.ModuleSpec.Spec.from_string(commands[1])
        dep_spec   = sumo.ModuleSpec.Spec.from_string(commands[2])
        state      = commands[3]
        db = db_from_json_file(options.db,
                keep_locked= not options.dumpdb and (not options.dry_run))
        db.add_dependency(module_spec.modulename,
                          module_spec.versionname,
                          dep_spec.modulename,
                          dep_spec.versionname,
                          state)
        if options.dumpdb:
            db.json_print()
        else:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="dependency-delete":
        if len(commands)<3:
            sys.exit("Two arguments must follow \"%s\"" % \
                     commands[0])
        if not options.db:
            sys.exit("error, --db is mandatory here")
        module_spec= sumo.ModuleSpec.Spec.from_string(commands[1])
        dep_spec   = sumo.ModuleSpec.Spec.from_string(commands[2])
        if module_spec.no_version_spec():
            sys.exit("module has no version")
        if dep_spec.no_version_spec():
            sys.exit("dependency has no version")

        db = db_from_json_file(options.db,
                keep_locked= not options.dumpdb and (not options.dry_run))
        db.del_dependency(module_spec.modulename,
                          module_spec.versionname,
                          dep_spec.modulename,
                          dep_spec.versionname)
        if options.dumpdb:
            db.json_print()
        else:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="cloneversion" or commands[0]=="replaceversion":
        do_replace= (commands[0]=="replaceversion")
        if len(commands)<4:
            sys.exit("at least three arguments must follow \"%s\"" % \
                     commands[0])
        (modulename, oldversion, newversion)= commands[1:4]
        if len(commands)<=4:
            sourcespec= None
        else:
            sourcespec= commands[4:]
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db = db_from_json_file(options.db,
                keep_locked= not options.dumpdb and (not options.dry_run))
        db.patch_version(modulename, oldversion, newversion, do_replace)
        if sourcespec:
            try:
                source_spec_dict= utils.scan_source_spec(sourcespec)
            except ValueError, e:
                sys.exit("Error: "+str(e))
            db.set_source(modulename, newversion,
                          source_spec_dict)
        if options.dumpdb:
            db.json_print()
        else:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="clonemodule":
        if len(commands)<3:
            sys.exit("at least two arguments must follow \"%s\"" % \
                     commands[0])
        (oldmodule, newodule)= commands[1:3]
        versions= commands[3:]
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db = db_from_json_file(options.db,
                keep_locked= not options.dumpdb and (not options.dry_run))
        db.clonemodule(oldmodule, newodule, versions)
        if options.dumpdb:
            db.json_print()
        else:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="list":
        if len(commands)>1:
            sys.exit("error: extra arguments following \"list\"")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= db_from_json_file(options.db)
        result= sorted(db.iter_modulenames())
        sumo.JSON.dump(result)
        return

    if commands[0]=="state":
        if len(commands)<=1:
            sys.exit("error: STATE and module missing")
        if len(commands)<=2:
            sys.exit("error: no modules specified")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        state= commands[1]
        modulespecs= commands[2:]
        db= db_from_json_file(options.db,
                keep_locked= not options.dumpdb and (not options.dry_run))
        try:
            sumo.Databases.Dependencies.check_state(state)
        except ValueError, e:
            sys.exit(str(e))
        try:
            modulespecs_obj= sumo.ModuleSpec.Specs.from_strings(modulespecs,
                                                                None)
        except ValueError, e:
            sys.exit(str(e))

        if options.dump_modules:
            dump_modules(modulespecs_obj)
            sys.exit(0)
        set_state(db, state, modulespecs_obj)
        if options.dumpdb:
            db.json_print()
        else:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="shownewest" or commands[0]=="showall":
        showall= (commands[0]=="showall")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        if not options.maxstate:
            sys.exit("error, --maxstate is mandatory here")
        db= db_from_json_file(options.db)

        modulespecs= []
        if options.module:
            modulespecs.extend(options.module)
        if len(commands)>1:
            modulespecs.extend(commands[1:])

        if not modulespecs:
            modulespecs= list(db.iter_modulenames())

        result= {}

        try:
            modulespecs_obj= sumo.ModuleSpec.Specs.from_strings(modulespecs,
                                                            options.arch)
        except ValueError, e:
            sys.exit(str(e))

        if options.dump_modules:
            dump_modules(modulespecs_obj)
            sys.exit(0)
        for modulespec in modulespecs_obj:
            modulename= modulespec.modulename

            versions= db.sorted_moduleversions(modulename, options.maxstate,
                                               options.arch, False)
            if not versions: # no versions match maxstate criteria
                continue
            versions= [v for v in versions \
                       if modulespec.test(v)]

            if not showall:
                result[modulename]= versions[0]
            else:
                result[modulename]= versions
        sumo.JSON.dump(result)
        return

    if commands[0]=="find":
        if len(commands)<=1:
            sys.exit("error: REGEXP missing")
        if not options.maxstate:
            sys.exit("error, --maxstate is mandatory here")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= db_from_json_file(options.db)
        regexp= commands[1]
        if options.noignorecase:
            rx_flags= 0
        else:
            rx_flags= re.IGNORECASE
        rx= re.compile(regexp, rx_flags)
        results= db.search_modules(rx, options.maxstate, options.arch)
        if options.brief:
            for (module,version) in results:
                print "%s:%s" % (module,version)
            return
        newdb= db.partial_copy_by_list(results)
        newdb.json_print()
        return

def print_summary():
    """print a short summary of the scripts function."""
    print "%-20s: a tool for managing support EPICS trees \n" % \
          script_shortname()

def _test():
    """does a self-test of some functions defined here."""
    print "performing self test..."
    import doctest
    doctest.testmod()
    print "done!"

usage = """usage: %prog [options] command
where command is:
  makeconfig {FILE}
          Create a new configuration file from the given options. If the
          filename is '-' dump to the console, if it is omitted, rewrite the
          configuration file that was read before (see option --config).
  edit [FILE]
          Start the editor specified by the environment variable "VISUAL" or
          "EDITOR" with that file. This command first aquires a file-lock on
          the file that is only released when the editor program is terminated.
          If you want to edit a DB or BUILDDB file directly, you should always
          do it with this with this command. The file locking prevents other
          users to use the file at the same time you modify it.
  convert [STATE] [SCANFILE]: 
          Convert SCANFILE to a new DB. All dependencies are marked with state
          STATE. STATE may be "stable", "testing" or "unstable".
  appconvert [SCANFILE] 
          Convert a SCANFILE that was created by applying sumo-scan to an
          application to a list of aliases and modulespecs in JSON format. The
          result is printed to the console. It can be used with --config
          to put these in the configuration file of sumo-db or sumo-build.
  state  [STATE] [modules]
          Set the state for modules. This command sets the given STATE for all
          the given modules and the dependencies between the modules.
  weight [WEIGHT] [modules]
          Set the weight factor for modules. Use
          modulename:{+-}versionname to select more versions of a module.
          This command *does not* use the --modules option.
          Weight must be an integer.
  list:   list the names of all modules
  shownewest {MODULES}: 
          Show newest version for each module. If {modules} is missing, take
          all modules of the database. Mandatory option "--maxstate" defines
          the "maximum" state modules may have.
  showall {MODULES}: 
          Show all versions for each module. If {modules} is missing, take all
          modules of the database. Mandatory option "--maxstate" defines
          the "maximum" state modules may have.
  filter [MODULES]
          Print the database for the given modules. If you want a specific
          version of a module use modulename:versioname instead of the
          modulename alone.
  find [REGEXP]
          Show all modules whose names or sources match regexp. Mandatory
          option "--maxstate" defines the "maximum" state modules may have.

  check 
          do some consistency checks on the db specifed by --db
  merge [DB]
          Merge the given db with the one specified by --db
  cloneversion [MODULE] [OLD-VERSION] [NEW-VERSION] {SOURCESPEC}
          Add a new version to the database by copying the old version. The
          old-version data is copied for the new version data. All modules that
          depend on module:old-version now alternatively depend on
          module:new-version. If sourcespec is given, the command changes the
          source part according to this parameter. A sourcespec has the form
          "path PATH" or "darcs URL" or "darcs URL TAG". Both, URL or TAG may
          be "*", in this case the original URL or TAG remains unchanged.
  replaceversion [MODULE] [OLD-VERSION] [NEW-VERSION] {SOURCESPEC}
          Replace a version to the database with a new one. The old-version
          data is copied for the new version data. All modules that depend on
          module:old-version now depend on module:new-version. If sourcespec
          is given, the command changes the source part according to this
          parameter. A sourcespec has the form "path PATH" or "darcs URL" or
          "darcs URL TAG". Both, URL or TAG may be "*", in this case the
          original URL or TAG remains unchanged.
  clonemodule [OLD-MODULE] [NEW-MODULE] {VERSIONS}
          Copy all versions of the existing old module and add this with the
          name of thew new module to the dependency database. If there are no
          versions specified, the command copies all existing versions. Note
          that this DOES NOT add the new module as dependency to any other
          modules.
  dependency-delete MODULE:VERSION DEPENDENCYNAME:DEPENDENCYVERSION
          Delete a dependency of a module.
  dependency-add MODULE:VERSION DEPENDENCYNAME:DEPENDENCYVERSION STATE
          Add a dependency to a module.
  alias-add MODULE:VERSION DEPENDENCYNAME ALIAS
          Add an alias to a module.
"""

def main():
    """The main function.

    parse the command-line options and perform the command
    """
    # command-line options and command-line help:

    parser = OptionParser(usage=usage,
                          version="%%prog %s" % my_version,
                          description="This program manages EPICS support trees"
                         )

    parser.add_option("--summary",
                      action="store_true",
                      help="Print a summary of the function of the program.",
                      )
    parser.add_option("--test",
                      action="store_true",
                      help="Perform simple self-test.",
                      )
    parser.add_option("-c", "--config",
                      action="append",
                      type="string",
                      help="Load options from the given configuration "
                           "file. You can specify more than one of these, "
                           "in this case the files are merged. If this "
                           "option is not given and --no-default-config "
                           "is not given, the program tries to load the "
                           "default configuration file %s." % CONFIG_NAME,
                      metavar="CONFIGFILE"
                      )
    parser.add_option("--no-default-config",
                      action="store_true",
                      help="If this option is given the program doesn't load "
                           "the default configuration.",
                      )
    parser.add_option("--#include",
                      action="append",
                      type="string",
                      help="Specify a an '#include' directive in the "
                           "configuration file.  This option has only a "
                           "meaning if a configuration file is created with "
                           "the 'makeconfig' command. '#include' means that "
                           "the following file(s) are included before the "
                           "rest of the configuration file. ",
                      metavar="INCLUDEFILES"
                      )
    parser.add_option("--db",
                      action="store",
                      type="string",
                      help= "Define the name of the DB file. This option "
                            "value is stored in the configuration file. ",
                      metavar="DB"
                      )
    parser.add_option("--dumpdb",
                      action="store_true",
                      help="Dump the db on the console, currently "
                           "only for these commands : %s." % \
                           (" ".join(("weight","merge",
                                      "clonemodule",
                                      "cloneversion", "replaceversion")))
                      )
    parser.add_option("--arch",
                      action="append",
                      help="Define the name of a TARGETARCHITECTURE. You "
                           "can specify more than one target architecture."
                           "You can specify more than one of these by "
                           "repeating this option or by joining values in "
                           "a single string separated by spaces. "
                           "This option value is stored in the "
                           "configuration file.",
                      metavar="TARGETARCHITECTURE"
                      )
    parser.add_option("-m", "--module",
                      action="append",
                      help= "Define a modulespec. If you specify modules "
                            "with this option you don't have to put "
                            "modulespecs after some of the commands.  You "
                            "can specify more than one of these by repeating "
                            "this option or by joining values in a single "
                            "string separated by spaces.  This option value "
                            "is stored in the configuration file. ",
                      metavar="MODULESPEC"
                      )
    parser.add_option("-M", "--maxstate",
                      action="store",
                      type="string",
                      help= "Specify the maximum state for some commands."
                            "This option value is stored in the "
                            "configuration file. ",
                      metavar="STATE"
                      )
    parser.add_option("-b", "--brief",
                      action="store_true",
                      help="Create a more brief output for some commands. ",
                      )
    parser.add_option("-P", "--source-patch",
                      action="append",
                      help="Specify a source PATCHEXPRESSION. Such an "
                           "expression consists of a tuple of 2 python "
                           "strings. The first is the match expression, "
                           "the second one is the replacement string. The "
                           "regular expression is applied to every source "
                           "url generated. You can specify more than one "
                           "PATCHEXPRESSION. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="PATCHEXPRESSION"
                      )
    parser.add_option("--noignorecase",
                      action="store_true",
                      help="For command 'find', do NOT ignore case.",
                      )
    parser.add_option("--nolock",
                      action="store_true",
                      help="Do not use file locking."
                      )
    parser.add_option("-p", "--progress",
                      action="store_true",
                      help= "Show progress on stderr. This option value is "
                            "stored in the configuration file. "
                      )
    parser.add_option("-t", "--trace",
                      action="store_true",
                      help="Switch on some trace messages.",
                      )
    parser.add_option("--dump-modules",
                      action="store_true",
                      help="Dump module specs, then stop the program.",
                      )
    parser.add_option("-v", "--verbose",
                      action="store_true",
                      help="Show command calls. This option value is stored "
                           "in the configuration file.",
                      )
    parser.add_option("-n", "--dry-run",
                      action="store_true",
                      help="Just show what the program would do.",
                      )

    # x= sys.argv
    (options, args) = parser.parse_args()
    # options: the options-object
    # args: list of left-over args

    # join some of the list options:
    options.arch  = utils.opt_join(options.arch, do_sort= True)
    options.module= utils.opt_join(options.module)

    if options.summary:
        print_summary()
        sys.exit(0)

    if options.test:
        _test()
        sys.exit(0)

    # we could pass "args" as an additional parameter to process here if it
    # would be needed to process remaining command line arguments.
    process(options, args)
    sys.exit(0)

if __name__ == "__main__":
    main()


