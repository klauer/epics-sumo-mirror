#! /usr/bin/env python
# -*- coding: UTF-8 -*-

# pylint: disable=C0111
#                          Missing docstring
# pylint: disable=C0301
#                          Line too long
# pylint: enable=C0301

# pylint: disable=C0103
#                          Invalid name ... for type module
# pylint: disable=C0322
#                          Operator not preceded by a space

from optparse import OptionParser
import sys
import os.path
import os
import re

import sumo.utils as utils

# version of the program:
my_version= "1.3"

KNOWN_COMMANDS=set(("edit", "convert",
                    "appconvert",
                    "distribution",
                    "makeconfig",
                    "weight",
                    "list", "shownewest", "showall",
                    "find",
                    "merge", "check", "filter",
                    "cloneversion", "replaceversion"))

CONFIG_NAME="sumo-db.config"

# -----------------------------------------------
# main
# -----------------------------------------------

def script_shortname():
    """return the name of this script without a path component."""
    return os.path.basename(sys.argv[0])


def create_app_data(deps, repoinfo, groups):
    """create configuration data for an app."""
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    def errmsg(msg):
        """print something on stderr."""
        sys.stderr.write(msg+"\n")
    keys= deps.keys()
    if len(keys)!=1:
        sys.exit("error: \"dependencies\" map must have exactly one key")

    modulespecs= []
    aliases    = []

    app_path= keys[0]
    specs_by_path= {}

    for module_name, groupdata in groups.items():
        keys= groupdata.keys()
        if len(keys)!=1:
            sys.exit("error: groupdata \"%s\" must have exactly one key" % \
                     module_name)
        root_path= keys[0]
        values= groupdata[root_path]
        if len(values)!=1:
            sys.exit("error: groudata \"%s\" must have exactly one "
                     "subdir" % module_name)
        subdir= values[0]
        versionedmodule_path= os.path.join(root_path, subdir)
        try:
            (repotype, repodata)= repoinfo.get_data(
                                           versionedmodule_path)
        except KeyError, _:
            # shouldn't happen, but we just print a warning in this
            # case:
            errmsg("no source data: %s" % versionedmodule_path)
            continue
        if repotype=="path":
            versionname= "PATH-%s" % subdir
        elif repotype=="darcs":
            if not repodata.has_key("tag"):
                versionname= "TAGLESS-%s" % subdir
            else:
                versionname= repodata["tag"]
        else:
            raise AssertionError("unknown repotype: "+repotype)
        specs_by_path[versionedmodule_path]= (module_name,versionname)

    for (aliasname, path) in deps[app_path].items():
        (module_name,versionname)= specs_by_path[path]
        modulespecs.append("%s:%s" % (module_name,versionname))
        if aliasname!=module_name:
            aliases.append("%s:%s" % (module_name, aliasname))
    aliases.sort()
    modulespecs.sort()

    return {"alias": aliases, "module": modulespecs}


def create_database(deps, repoinfo, groups, archs, state, source_patches):
    """join the information of the three sources.
    """
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0915
    #                          Too many statements
    # pylint: disable=R0913
    #                          Too many arguments
    def errmsg(msg):
        """print something on stderr."""
        sys.stderr.write(msg+"\n")

    try:
        state= utils.Builddb.guess_state(state)
    except ValueError, e:
        sys.exit(str(e))
    patcher= utils.RegexpPatcher()
    if source_patches:
        for p in source_patches:
            patcher.add(eval(p))
    _path2namevname= {}
    _namevname2path= {}
    db= utils.Dependencies()
    # we first create the map from modulenames to versiondata. In this loop we
    # populate the versiondata only with the source specification. We also
    # create two maps:
    #    _path2namevname: maps a diretory path to (module_name, versionname)
    #    _namevname2path: maps (module_name,versionname) to a diretory path
    for module_name, groupdata in groups.items():
        # the root directory of all the versions:
        for root_path, subdirs in groupdata.items():
            for subdir in sorted(subdirs):
                # iterate over all versions from <groups>:
                # reconstruct the original directory path:
                versionedmodule_path= os.path.join(root_path, subdir)
                # get the repository data:
                try:
                    (repotype, repodata)= repoinfo.get_data(
                                                   versionedmodule_path)
                except KeyError, _:
                    # shouldn't happen, but we just print a warning in this
                    # case:
                    errmsg("no source data: %s" % versionedmodule_path)
                    continue

                if repotype=="path":
                    # the source is a directory path, not a repository. We
                    # generate the unique versionname:
                    if subdir.startswith("PATH-"):
                        # Try to handle a subdir that was created by this set
                        # of tools. Such a subdir may already be named
                        # "PATH-<name>+<treetag>". We want to take <name> as
                        # versionname in this case:
                        versionname= utils.split_treetag(subdir)[0]
                    else:
                        versionname= "PATH-%s" % subdir
                    # repodata is just the path in this case:
                    repodata= patcher.apply(repodata)
                elif repotype=="darcs":
                    if not repodata.has_key("tag"):
                        # the source is a darcs repository but has no tag. We
                        # generate a unique versionname:
                        if subdir.startswith("TAGLESS-"):
                            # Try to handle a subdir that was created by this
                            # set of tools. Such a subdir may already be named
                            # "PATH-<name>+<treetag>". We want to take <name>
                            # as versionname in this case:
                            versionname= utils.split_treetag(subdir)[0]
                        else:
                            versionname= "TAGLESS-%s" % subdir
                        # patch URL to <versionedmodule_path>. Since we do not
                        # know in what state the working copy repository is, we
                        # have to take this as a source instead of the central
                        # repository:
                        repodata= {"url": patcher.apply(versionedmodule_path)}
                    else:
                        # make a copy of repodata so we can modify it:
                        repodata= dict(repodata)
                        repodata["url"]= patcher.apply(repodata["url"])
                        # the source is a darcs repository with a tag. We use
                        # the tag as unique versionname:
                        versionname= repodata["tag"]
                module_archs= archs.get(versionedmodule_path, [])
                if not module_archs:
                    #  module_archs list is empty:
                    errmsg("no archs for path %s" % \
                           versionedmodule_path)
                db.set_source_arch_state(module_name, versionname,
                                         module_archs, state,
                                         {repotype: repodata})

                _path2namevname[versionedmodule_path]= \
                        (module_name,versionname)
                # when we assume that a versionedmodule_path may contain a
                # buildtag, there may be several versionedmodule_paths for a
                # pair of (module_name, versionname).
                _paths= _namevname2path.setdefault(
                                    (module_name, versionname),[])
                _paths.append(versionedmodule_path)

    #utils.json_dump(_path2namevname)
    #sys.exit(0)

    # here we populate the versiondata with the dependency specifications:
    for modulename in db.iter_modulenames():
        # loop on stable, testing and unstable versions:
        for versionname in db.iter_versions(modulename, "unstable",
                                            None, False):
            versionedmodule_paths= _namevname2path[(modulename, versionname)]

            for versionedmodule_path in versionedmodule_paths:
                _deps= deps.get(versionedmodule_path)
                if _deps is None:
                    errmsg("no dependency info for path %s" % \
                           versionedmodule_path)
                    continue
                for alias, dep_path in _deps.items():
                    try:
                        (_dep_name, _dep_version)= _path2namevname[dep_path]
                    except KeyError, _:
                        sys.exit(("at module %s version %s "+ \
                                  "path %s: "+ \
                                  "missing data for "+ \
                                  "dependency \"%s\"") % \
                                  (modulename, versionname,
                                   versionedmodule_path,
                                   dep_path))
                    if _dep_name != alias:
                        try:
                            db.add_alias(modulename, versionname,
                                         alias, _dep_name)
                        except ValueError, e:
                            errmsg("alias error in module %s: %s" % \
                                   (modulename, str(e)))
                    db.add_dependency(modulename, versionname,
                                      _dep_name, _dep_version, state)
    return db

def _distribution_add(db, dist, modulename, versionname, maxstate, archs):
    """add a module to the set."""
    # pylint: disable=R0913
    #                          Too many arguments
    #print "_distribution_add(..,..,",modulename,",",versionname,")"
    existing_versionname= dist.get(modulename)
    if existing_versionname is not None:
        if existing_versionname!= versionname:
            raise ValueError("conflict: %s %s %s" % \
                      (modulename, existing_versionname, versionname))
        return dist
    if not db.check_archs(modulename, versionname, archs):
        raise ValueError("no support for archs %s in module %s:%s" % \
                         (repr(archs),modulename,versionname))
    new_dist= dict(dist)
    # ^^^ caution, not a deep copy
    new_dist[modulename]= versionname
    try:
        if not db.dependencies_found(modulename, versionname):
            return new_dist
    except KeyError, e:
        sys.exit("no information for module %s version %s" % \
                 (modulename, versionname))

    for dep_modulename in db.iter_dependencies(modulename, versionname):
        for dep_version in db.sorted_dependency_versions(
                modulename, versionname, dep_modulename, maxstate, archs):
            errst= None
            try:
                new_dist= _distribution_add(db,
                                            new_dist,
                                            dep_modulename,
                                            dep_version, maxstate, archs)
                errst= None
                break
            except ValueError, e:
                errst= str(e)
        if errst:
            raise ValueError("no module found, last error message: %s" % \
                             errst)
    return new_dist

def distribution(db, modulespec_list, maxstate, archs, trace):
    """create a distribution.
    """
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    if trace:
        sys.stderr.write("looking for modules, archs: %s maxstate: %s\n\n" % \
                         (repr(archs), maxstate))

    versioned_modules= []
    versionless_modules= []
    modulespecs= utils.ModuleSpecs.from_strings(modulespec_list, archs)
    for modulespec in modulespecs:
        modulename= modulespec.modulename
        if modulespec.no_version_spec():
            versionless_modules.append((modulename, modulespec.archs))
        elif modulespec.is_exact_spec():
            versioned_modules.append((modulename,
                                      modulespec.versionname,
                                      modulespec.archs))
        else:
            raise ValueError("\"-version\" and \"+version\" not "
                             "supported here")
    dist= {}
    for (modulename, versionname, archs) in versioned_modules:
        try:
            dist= _distribution_add(db, dist, modulename, versionname,
                                    maxstate, archs)
        except ValueError, e:
            sys.exit(str(e))

    for (modulename, archs) in versionless_modules:
        if trace:
            sys.stderr.write("module %s\n" % modulename)
        try:
            versionlist= db.sorted_moduleversions(modulename, maxstate,
                                                  archs, True)
        except KeyError, e:
            sys.exit("no data for module %s" % modulename)
        except ValueError, e:
            sys.exit("Error: %s" % str(e))

        found= False
        for versionname in versionlist:
            try:
                dist= _distribution_add(db, dist, modulename, versionname,
                                        maxstate, archs)
                found= True
                break
            except ValueError, e:
                if trace:
                    sys.stderr.write("\t%-15s: %s\n" % \
                                     (versionname, str(e)))
        if not found:
            sys.exit("no non conflicting versions found for %s" % modulename)
        else:
            if trace:
                sys.stderr.write("\t%-15s --> found\n" % versionname)

    spec_list= []
    for (m,v) in dist.items():
        spec_list.append(utils.ModuleSpec(m, v, "eq", None))
    new= db.partial_copy_by_modulespecs(utils.ModuleSpecs(spec_list))
    new.remove_missing_deps()
    return (dist,new)

def set_weight(db, weight, modulespeclist, trace):
    """set the weight for one or more modules."""
    modulespecs= utils.ModuleSpecs.from_strings(modulespeclist, None)
    for modulespec in modulespecs:
        modulename= modulespec.modulename
        if trace:
            sys.stderr.write("%s\n" % modulespec.to_string())

        # scan stable, testing and unstable versions:
        for version in db.iter_versions(modulename, "unstable",
                                        None, must_exist= False):
            if trace:
                sys.stderr.write("test %s:%s\n" % (modulename,version))
            if not modulespec.test(version):
                continue
            if trace:
                sys.stderr.write("set weight %d on %s:%s\n" % \
                                 (weight,modulename,version))
            db.weight(modulename, version, weight)

def process(options, commands):
    """do all the work.
    """
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    # pylint: disable=R0911
    #                          Too many return statements
    # pylint: disable=R0915
    #                          Too many statements

    config= utils.ConfigFile.from_optionlist(
                CONFIG_NAME,
                ( "arch", "db", "maxstate", "module", "progress",
                  "source_patch", "verbose"))
    if (not os.path.exists(CONFIG_NAME)) or options.no_default_config:
        config.disable_default()

    if options.addmodules:
        # "module" option is now *merged*, not copied in
        # update_from_options:
        config.set_list_append("module")

    config.load(options.config)

    config.merge_options(options)

    if options.nolock:
        utils.use_lockfile= False
    if not commands:
        sys.exit("command missing")
    if commands[0] not in KNOWN_COMMANDS:
        sys.exit("unknown command: %s" % commands[0])

    if commands[0]=="makeconfig":
        if len(commands)>1:
            sys.exit("error: extra arguments following \"makeconfig\"")
        if len(commands)<=1:
            configfile= None
        else:
            configfile= commands[1]
        config.save(configfile)
        return

    if commands[0]=="edit":
        if len(commands)!=2:
            sys.exit("exactly one filename must follow \"edit\"")
        utils.edit_with_lock(commands[1], options.verbose, options.dry_run)
        return

    if commands[0]=="convert":
        if len(commands)!=3:
            sys.exit("a state and a filename must follow \"convert\"")
        (state, filename)= commands[1:]
        scandata= utils.json_loadfile(filename)
        deps= scandata["dependencies"]
        repoinfo= utils.PathSource(scandata["repos"])
        groups= scandata["groups"]
        archs= scandata["archs"]
        db= create_database(deps, repoinfo, groups, archs, state,
                            options.source_patch)
        db.json_print()
        return

    if commands[0]=="appconvert":
        if len(commands)!=2:
            sys.exit("a filename must follow \"convert\"")
        filename= commands[1]
        scandata= utils.json_loadfile(filename)
        deps= scandata["dependencies"]
        repoinfo= utils.PathSource(scandata["repos"])
        groups= scandata["groups"]
        struc= create_app_data(deps, repoinfo, groups)
        utils.json_dump(struc)
        return

    if commands[0]=="distribution":
        if len(commands)>1:
            if options.addmodules:
                modulespecs= options.module + commands[1:]
            else:
                modulespecs= commands[1:]
        else:
            # no modulespecs after the command
            modulespecs= options.module
            if not modulespecs:
                sys.exit("error: module specs missing")
        if not options.maxstate:
            sys.exit("error, --maxstate is mandatory here")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= utils.Dependencies.from_json_file(options.db)
        (dist_dict, dist_obj)= distribution(db, modulespecs,
                                            options.maxstate, options.arch,
                                            options.trace)
        if options.brief:
            utils.json_dump(dist_dict)
        else:
            dist_obj.json_print()
        return

    if commands[0]=="weight":
        if len(commands)<=1:
            sys.exit("error: WEIGHT and module missing")
        if len(commands)<=2:
            sys.exit("error: no modules specified")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        weight= commands[1]
        modulespecs= commands[2:]
        try:
            weight= int(weight)
        except ValueError, _:
            sys.exit("error: weight must be an integer")
        db= utils.Dependencies.from_json_file(options.db,
                keep_locked= not options.dumpdb and (not options.dry_run))
        set_weight(db, weight, modulespecs, options.trace)
        if options.dumpdb:
            db.json_print()
        else:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="filter":
        if len(commands)>1:
            if options.addmodules:
                modulespecs= options.module + commands[1:]
            else:
                modulespecs= commands[1:]
        else:
            # no modulespecs after the command
            modulespecs= options.module
            if not modulespecs:
                sys.exit("error: module specs missing")

        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= utils.Dependencies.from_json_file(options.db, keep_locked= False)
        modulespecs_obj= utils.ModuleSpecs.from_strings(modulespecs,
                                                        options.archs)
        db= db.partial_copy_by_modulespecs(modulespecs_obj)
        db.json_print()
        return

    if commands[0]=="check":
        if len(commands)>1:
            sys.exit("error: extra arguments following \"check\"")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db = utils.Dependencies.from_json_file(options.db,
                                               keep_locked= False)
        msg= db.check()
        print "\n".join(msg)
        return

    if commands[0]=="merge":
        if len(commands)!=2:
            sys.exit("exactly one filename must follow \"merge\"")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db = utils.Dependencies.from_json_file(options.db,
                keep_locked= not options.dumpdb and (not options.dry_run))
        db2= utils.Dependencies.from_json_file(commands[1])
        db.merge(db2)
        if options.dumpdb:
            db.json_print()
        else:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="cloneversion" or commands[0]=="replaceversion":
        do_replace= (commands[0]=="replaceversion")
        if len(commands)<4:
            sys.exit("at least three arguments must follow \"%s\"" % \
                     commands[0])
        (modulename, oldversion, newversion)= commands[1:4]
        if len(commands)<=4:
            sourcespec= None
        else:
            sourcespec= commands[4:]
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db = utils.Dependencies.from_json_file(options.db,
                keep_locked= not options.dumpdb and (not options.dry_run))
        db.patch_version(modulename, oldversion, newversion, do_replace)
        if sourcespec:
            db.set_source(modulename, newversion,
                          utils.scan_source_spec(sourcespec))
        if options.dumpdb:
            db.json_print()
        else:
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="list":
        if len(commands)>1:
            sys.exit("error: extra arguments following \"list\"")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= utils.Dependencies.from_json_file(options.db)
        result= sorted(db.iter_modulenames())
        utils.json_dump(result)
        return

    if commands[0]=="shownewest" or commands[0]=="showall":
        showall= (commands[0]=="showall")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        if not options.maxstate:
            sys.exit("error, --maxstate is mandatory here")
        db= utils.Dependencies.from_json_file(options.db)

        if len(commands)>1:
            if options.addmodules:
                modulespecs= options.module + commands[1:]
            else:
                modulespecs= commands[1:]
        else:
            # no modulespecs after the command
            modulespecs= options.module
            if not modulespecs:
                modulespecs= list(db.iter_modulenames())

        result= {}

        modulespecs_obj= utils.ModuleSpecs.from_strings(modulespecs,
                                                        options.arch)
        for modulespec in modulespecs_obj:
            modulename= modulespec.modulename

            versions= db.sorted_moduleversions(modulename, options.maxstate,
                                               options.arch, False)
            if not versions: # no versions match maxstate criteria
                continue
            versions= [v for v in versions \
                       if modulespec.test(v)]

            if not showall:
                result[modulename]= versions[0]
            else:
                result[modulename]= versions
        utils.json_dump(result)
        return

    if commands[0]=="find":
        if len(commands)<=1:
            sys.exit("error: REGEXP missing")
        if not options.maxstate:
            sys.exit("error, --maxstate is mandatory here")
        if not options.db:
            sys.exit("error, --db is mandatory here")
        db= utils.Dependencies.from_json_file(options.db)
        regexp= commands[1]
        if options.noignorecase:
            rx_flags= 0
        else:
            rx_flags= re.IGNORECASE
        rx= re.compile(regexp, rx_flags)
        results= db.search_modules(rx, options.maxstate, options.arch)
        if options.brief:
            for (module,version) in results:
                print "%s:%s" % (module,version)
            return
        newdb= db.partial_copy_by_list(results)
        newdb.json_print()
        return

def print_summary():
    """print a short summary of the scripts function."""
    print "%-20s: a tool for managing support EPICS trees \n" % \
          script_shortname()

def _test():
    """does a self-test of some functions defined here."""
    print "performing self test..."
    import doctest
    doctest.testmod()
    print "done!"

usage = """usage: %prog [options] command
where command is:
  makeconfig {FILE}
          Create a new configuration file from the given options. If the
          filename is '-' dump to the console, if it is omitted, rewrite the
          configuration file that was read before (see option --config).
  edit [FILE]
          Start the editor specified by the environment variable "VISUAL" or
          "EDITOR" with that file. This command first aquires a file-lock on
          the file that is only released when the editor program is terminated.
          If you want to edit a DB or BUILDDB file directly, you should always
          do it with this with this command. The file locking prevents other
          users to use the file at the same time you modify it.
  convert [STATE] [SCANFILE]: 
          Convert SCANFILE to a new DB. All dependencies are marked with state
          STATE. STATE may be "stable", "testing" or "unstable".
  appconvert [SCANFILE] 
          Convert a SCANFILE that was created by applying sumo-scan to an
          application to a list of aliases and modulespecs in JSON format. The
          result is printed to the console. It can be used with --config
          to put these in the configuration file of sumo-db or sumo-build.
  distribution [MODULES]: 
          Create distribution from DB where all specified modules are
          contained. If you want a specific version of a module use
          modulename:versioname instead of the modulename alone. 
          Option --maxstate is mandatory for this command.
  weight [WEIGHT] [modules]
          Set the weight factor for modules. Use
          modulename:{+-}versionname to select more versions of a module.
          This command *does not* use the --modules option.
          Weight must be an integer.
  list:   list the names of all modules
  shownewest {MODULES}: 
          Show newest version for each module. If {modules} is missing, take
          all modules of the database. Mandatory option "--maxstate" defines
          the "maximum" state modules may have.
  showall {MODULES}: 
          Show all versions for each module. If {modules} is missing, take all
          modules of the database. Mandatory option "--maxstate" defines
          the "maximum" state modules may have.
  filter [MODULES]
          Print the database for the given modules. If you want a specific
          version of a module use modulename:versioname instead of the
          modulename alone.
  find [REGEXP]
          Show all modules whose names or sources match regexp. Mandatory
          option "--maxstate" defines the "maximum" state modules may have.

  check 
          do some consistency checks on the db specifed by --db
  merge [DB]
          Merge the given db with the one specified by --db
  cloneversion [MODULE] [OLD-VERSION] [NEW-VERSION] {SOURCESPEC}
          Add a new version to the database by copying the old version. The
          old-version data is copied for the new version data. All modules that
          depend on module:old-version now alternatively depend on
          module:new-version.
          If sourcespec is given, the command changes the source part according
          to this parameter. A sourcespec has the form "path PATH" or
          "darcs URL" or "darcs URL TAG".
  replaceversion [MODULE] [OLD-VERSION] [NEW-VERSION]
          Replace a version to the database with a new one. The old-version
          data is copied for the new version data. All modules that depend on
          module:old-version now depend on module:new-version.
"""

def main():
    """The main function.

    parse the command-line options and perform the command
    """
    # command-line options and command-line help:

    parser = OptionParser(usage=usage,
                          version="%%prog %s" % my_version,
                          description="This program manages EPICS support trees"
                         )

    parser.add_option("--summary",
                      action="store_true",
                      help="Print a summary of the function of the program.",
                      )
    parser.add_option("--test",
                      action="store_true",
                      help="Perform simple self-test.",
                      )
    parser.add_option("-c", "--config",
                      action="append",
                      type="string",
                      help="Load options from the given configuration "
                           "file. You can specify more than one of these, "
                           "in this case the files are merged. If this "
                           "option is not given and --no-default-config "
                           "is not given, the program tries to load the "
                           "default configuration file %s." % CONFIG_NAME,
                      metavar="CONFIGFILE"
                      )
    parser.add_option("--no-default-config",
                      action="store_true",
                      help="If this option is given the program doesn't load "
                           "the default configuration.",
                      )
    parser.add_option("--db",
                      action="store",
                      type="string",
                      help= "Define the name of the DB file. This option "
                            "value is stored in the configuration file. ",
                      metavar="DB"
                      )
    parser.add_option("--dumpdb",
                      action="store_true",
                      help="Dump the db on the console, currently "
                           "only for these commands : %s." % \
                           (" ".join(("weight","merge",
                                      "cloneversion", "replaceversion")))
                      )
    parser.add_option("--arch",
                      action="append",
                      help="Define the name of a TARGETARCHITECTURE. You "
                           "can specify more than one target architecture."
                           "You can specify more than one of these by "
                           "repeating this option or by joining values in "
                           "a single string separated by spaces. "
                           "This option value is stored in the "
                           "configuration file.",
                      metavar="TARGETARCHITECTURE"
                      )
    parser.add_option("-m", "--module",
                      action="append",
                      help= "Define a modulespec. If you specify modules "
                            "with this option you don't have to put "
                            "modulespecs after some of the commands.  You "
                            "can specify more than one of these by repeating "
                            "this option or by joining values in a single "
                            "string separated by spaces.  This option value "
                            "is stored in the configuration file. ",
                      metavar="MODULESPEC"
                      )
    parser.add_option("-M", "--maxstate",
                      action="store",
                      type="string",
                      help= "Specify the maximum state for some commands."
                            "This option value is stored in the "
                            "configuration file. ",
                      metavar="STATE"
                      )
    parser.add_option("-A", "--addmodules",
                      action="store_true",
                      help="If set, modules from the command do not replace "
                           "modules from the configuration file but are "
                           "*added* to them. Module specifications of the "
                           "form \"module:-\" remove a module from the "
                           "list of specs."
                      )
    parser.add_option("-b", "--brief",
                      action="store_true",
                      help="Create a more brief output for some commands. ",
                      )
    parser.add_option("-P", "--source-patch",
                      action="append",
                      help="Specify a source PATCHEXPRESSION. Such an "
                           "expression consists of a tuple of 2 python "
                           "strings. The first is the match expression, "
                           "the second one is the replacement string. The "
                           "regular expression is applied to every source "
                           "url generated. You can specify more than one "
                           "PATCHEXPRESSION. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="PATCHEXPRESSION"
                      )
    parser.add_option("--noignorecase",
                      action="store_true",
                      help="For command 'find', do NOT ignore case.",
                      )
    parser.add_option("--nolock",
                      action="store_true",
                      help="Do not use file locking."
                      )
    parser.add_option("-p", "--progress",
                      action="store_true",
                      help= "Show progress on stderr. This option value is "
                            "stored in the configuration file. "
                      )
    parser.add_option("-t", "--trace",
                      action="store_true",
                      help="Switch on some trace messages.",
                      )
    parser.add_option("-v", "--verbose",
                      action="store_true",
                      help="Show command calls. This option value is stored "
                           "in the configuration file.",
                      )
    parser.add_option("-n", "--dry-run",
                      action="store_true",
                      help="Just show what the program would do.",
                      )

    # x= sys.argv
    (options, args) = parser.parse_args()
    # options: the options-object
    # args: list of left-over args

    # join some of the list options:
    options.arch  = utils.opt_join(options.arch, do_sort= True)
    options.module= utils.opt_join(options.module)

    if options.summary:
        print_summary()
        sys.exit(0)

    if options.test:
        _test()
        sys.exit(0)

    # we could pass "args" as an additional parameter to process here if it
    # would be needed to process remaining command line arguments.
    process(options, args)
    sys.exit(0)

if __name__ == "__main__":
    main()


