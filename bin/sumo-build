#! /usr/bin/env python
# -*- coding: UTF-8 -*-

# pylint: disable=C0111
#                          Missing docstring
# pylint: disable=C0103
#                          Invalid name ... for type module
# pylint: disable=C0322
#                          Operator not preceded by a space

from optparse import OptionParser
import sys
import os.path
import os
import errno
import shutil

import sumo.utils as utils

# version of the program:
my_version= "1.2"

KNOWN_COMMANDS=set(( "cleanup", "delete", "edit", "find", "list", "new",
                     "partialdb", "show", "state", "use", "useall",
                  ))

CONFIG_NAME="sumo-build.config"

# -----------------------------------------------
# main
# -----------------------------------------------

def ensure_dir(dir_, dry_run):
    """create a dir if it doesn't already exist.
    """
    if not dry_run:
        if not os.path.exists(dir_):
            os.makedirs(dir_)

def rm_empty_dir(dirname, verbose, dry_run):
    """remove a directory.

    If the directory is not empty, return without an error message.
    """
    if verbose:
        print "remove dir %s if it is empty" % dirname
    if dry_run:
        return
    try:
        os.rmdir(dirname)
    except OSError, ex:
        if ex.errno == errno.ENOTEMPTY:
            pass

def module_dir_string(buildtag, modulename, versionname):
    """create a module directory string."""
    subdir= "%s+%s" % (versionname, buildtag)
    return os.path.join(modulename, subdir)

def module_basedir_string(modulename):
    """create a module base directory string."""
    return modulename

def scan_aliases(aliases):
    """scan aliases given on the command line."""
    d= {}
    if not aliases:
        return d
    for a in aliases:
        (from_, to)= a.split(":")
        d[from_]= to
    return d

def alias(alias_dict, modulename):
    """return a module alias."""
    n= alias_dict.get(modulename)
    if n is None:
        return modulename
    return n

def errmsg(msg):
    """print something on stderr."""
    sys.stderr.write(msg+"\n")

def makefilename(build_tag):
    """create a makefile name from a build_tag."""
    return("Makefile-%s" % build_tag)

def cleanupfilename(build_tag):
    """create the name of the cleanup file."""
    return("cleanup-%s" % build_tag)

def rmcleanup(build_tag):
    """remove the cleanup file."""
    fn= cleanupfilename(build_tag)
    if os.path.exists(fn):
        return os.remove(fn)

def loadcleanup(build_tag, must_exist= False):
    """load the cleanup file."""
    fn= cleanupfilename(build_tag)
    if os.path.exists(fn):
        return utils.json_loadfile(fn)
    if must_exist:
        raise IOError("file '%s' not found" % fn)
    return {"modules": [] }

def savecleanup(build_tag, struc):
    """save the cleanup file."""
    fn= cleanupfilename(build_tag)
    utils.json_dump_file(fn, struc)

def gather_dependencies(db, modulename, versionname,
                        gathered_deps):
    """recursively gather all dependencies of a module.

    returns a dict mapping modulenames to versionnames
    """
    if gathered_deps is None:
        gathered_deps= {}
    for dep_name in db.iter_dependencies(modulename, versionname):
        # get all depdendencies, even ones marked "unstable", take
        # archs==None:
        #   ignore architecture
        dep_versions= list(db.iter_dependency_versions(modulename,
                                                       versionname,
                                                       dep_name,
                                                       "unstable",
                                                       None))
        # Here we expect a unique version for each dependency of the module.
        if len(dep_versions)>1:
            raise AssertionError("m:%s v:%s d:%s dv:%s" % \
                    (modulename, versionname, dep_name, repr(dep_versions)))
        dep_version= dep_versions[0]
        existing= gathered_deps.get(dep_name)
        if existing is not None:
            if existing!=dep_version:
                raise AssertionError(
                      "version conflict module %s versions %s %s" % \
                      (modulename, existing, dep_version))
            # if this is already in gathered_deps we can skip recursion here
            continue
        gathered_deps[dep_name]= dep_version
        gathered_deps= gather_dependencies(db, dep_name,  dep_version,
                                           gathered_deps)
    return gathered_deps

def _add_dependencies(module_dict, db, build_module_dict,
                      modulename, versionname):
    """recursively add missing dependencies."""
    try:
        db.assert_module(modulename, versionname)
    except KeyError, e:
        sys.exit("%s in db file" % str(e))
    for dep in db.iter_dependencies(modulename, versionname):
        if module_dict.has_key(dep):
            continue
        version_present= build_module_dict[dep]
        if not db.depends_on(modulename, versionname, dep, version_present):
            str_= ("warning: dependency %s:%s is not in list "+ \
                   "of dependecies of module %s:%s in db file\n") % \
                   (dep,version_present,modulename,versionname)
            sys.stderr.write(str_)
        module_dict[dep]= version_present
        _add_dependencies(module_dict, db, build_module_dict,
                          dep, version_present)

def get_dependencies(module_dict, db, builddb, buildtag):
    """recursively complete the module_dict for missing dependencies."""
    build_module_dict= builddb.modules(buildtag)
    modules= module_dict.items()
    for modulename, versionname in modules:
        _add_dependencies(module_dict, db,
                          build_module_dict, modulename, versionname)

def builddb_match(db, builddb, modulename, versionname):
    """try to find matching deps in builddb.
    """
    deps= gather_dependencies(db, modulename, versionname, None)
    # now deps is a dict mapping modulenames to versionnames that contains all
    # direct and indirect dependencies of modulename:versionname that was
    # given to this function.
    for build_tag in builddb.iter_builds():
        # try to find modules that were already built, ignore builds that are
        # not marked "stable":
        if not builddb.is_stable(build_tag):
            continue
        if not builddb.has_module(build_tag, modulename):
            continue
        if builddb.module_link(build_tag, modulename):
            # if this build has only a link of the module, skip it
            continue
        modules= builddb.modules(build_tag)
        if modules[modulename]!=versionname:
            # version doesn't match
            continue

        # from here: check if all dependencies match:
        match= True
        for module_name, versionname in deps.items():
            other= modules.get(module_name)
            if versionname!= other:
                match= False
                break
        if match:
            return build_tag
    return

def _config_dir(build_tag, module_name, versionname, dry_run):
    """get the config dir name."""
    dir_= module_dir_string(build_tag, module_name, versionname)
    config_dir= os.path.join(dir_, "configure")
    if not dry_run:
        if not os.path.exists(config_dir):
            errmsg("no configure directory found in %s" % dir_)
            return
    return config_dir

def _fwrite(fh, st, verbose, dry_run):
    """write a line to a file."""
    if verbose:
        print st,
    if not dry_run:
        fh.write(st)

def gen_RELEASE(db, builddb, buildtag, modulename, versionname,
                extra_lines,
                verbose, dry_run):
    """generate a RELEASE file.

    This function requires that the current working directory is the support
    directory!

    Note: the SUPPORT path is the directory of the builddb file!
    """
    # pylint: disable=R0913
    #                          Too many arguments
    # pylint: disable=R0914
    #                          Too many local variables
    config_dir= _config_dir(buildtag, modulename, versionname, dry_run)
    if config_dir is None:
        return
    filename= os.path.join(config_dir, "RELEASE")
    if verbose:
        print "creating %s" % filename
    if not dry_run:
        fh= open(filename, "w")

    supportdir= os.getcwd()
    _fwrite(fh, "SUPPORT=%s\n" % supportdir, verbose, dry_run)
    deps= []
    for dep_name in db.iter_dependencies(modulename, versionname):
        # get all depdendencies, even ones marked "unstable":
        # archs==None:
        #   ignore architecture
        dep_versions= list(db.iter_dependency_versions(modulename,
                                                       versionname,
                                                       dep_name,
                                                       "unstable",
                                                       None))
        dep_versionname= dep_versions[0]
        deps.append((dep_name, dep_versionname))

    deps= db.sortby_weight(db.sortby_dependency(sorted(deps), True))
    for (dep_name, dep_versionname) in deps:
        name_here= db.get_alias(modulename, versionname, dep_name)
        buildtag_here= builddb.module_link(buildtag, dep_name)
        if buildtag_here is None:
            buildtag_here= buildtag
        path= os.path.join("$(SUPPORT)",
                           module_dir_string(buildtag_here, dep_name,
                                             dep_versionname)
                          )
        _fwrite(fh, "%s=%s\n" % (name_here,path), verbose, dry_run)
    for l in extra_lines:
        _fwrite(fh, "%s\n" % l.rstrip(), verbose, dry_run)
    if not dry_run:
        fh.close()

def create_source(db, modulename, versionname,
                  destdir, verbose, dry_run):
    """create directory by given source spec.
    """
    # pylint: disable=R0913
    #                          Too many arguments
    (sourcetype, sourcedata)= db.module_source_dict(modulename, versionname)
    if sourcetype=="path":
        #cmd= "scp -r -p \"%s\" %s" % (url, destdir)
        # join(url,"") effectively adds a "/" at the end of the path. This is
        # needed in order for rsync to work as intended here.
        cmd= "rsync -a -u -L --chmod=Fu+w \"%s\" %s" % \
             (os.path.join(sourcedata,""), destdir)
        utils.system(cmd, False, False, verbose, dry_run)
    elif sourcetype=="darcs":
        cmd_l= ["darcs", "get"]
        if sourcedata.has_key("tag"):
            cmd_l.extend(["-t", sourcedata["tag"]])
        cmd_l.append(sourcedata["url"])
        cmd_l.append(destdir)
        cmd= " ".join(cmd_l)
        utils.system(cmd, False, False, verbose, dry_run)
    else:
        raise AssertionError("unsupported source type %s" % sourcetype)

def delete_module(build_tag, modulename, versionname,
                  must_exist,
                  verbose, dry_run):
    """delete a single module."""
    # pylint: disable=R0913
    #                          Too many arguments
    dirname= module_dir_string(build_tag, modulename, versionname)
    if verbose:
        print "removing %s" % dirname
    if not dry_run:
        if os.path.exists(dirname):
            shutil.rmtree(dirname)
        else:
            if must_exist:
                raise IOError("error: '%s' doesn't exist" % dirname)
        # remove the parent directory if it is empty:
    rm_empty_dir(modulename, verbose, dry_run)

def delete_modules(builddb, build_tag, verbose, dry_run):
    """delete modules of a build.
    """
    for b in builddb.iter_builds():
        if builddb.is_linked_to(b, build_tag):
            raise ValueError("error: other builds depend on build %s" % \
                              build_tag)
    for modulename, versionname in builddb.iter_modules(build_tag):
        if builddb.module_link(build_tag, modulename):
            continue
        delete_module(build_tag, modulename, versionname, True,
                      verbose, dry_run)

    os.remove(makefilename(build_tag))

    builddb.delete(build_tag)

def cleanup_modules(build_tag, verbose, dry_run):
    """cleanup remains of a failed build.

    This can only happen if a "new" command was aborted due to an exception in
    the script.
    """
    try:
        cleanup_struc= loadcleanup(build_tag, must_exist= True)
    except IOError, e:
        sys.exit(str(e))

    module_list= cleanup_struc["modules"]
    for module_dict in module_list:
        delete_module(build_tag,
                      module_dict["modulename"],
                      module_dict["versionname"],
                      False,
                      verbose, dry_run)
    makefile= cleanup_struc.get("makefile")
    if makefile:
        if os.path.exists(makefile):
            os.remove(makefile)
    if not dry_run:
        rmcleanup(build_tag)

def create_module(db, builddb, build_tag,
                  modulename, versionname,
                  extra_defs,
                  archs,
                  verbose, dry_run):
    """check out a module.

    returns the build_tag that was used. If the module was found in another
    build, return that built-tag.

    This function requires that the current working directory is the
    support directory!
    """
    # pylint: disable=R0913
    #                          Too many arguments
    if not db.check_archs(modulename, versionname, archs):

        sys.stderr.write("error: archs %s\nnot supportted by "
                         "module %s:%s\n" % \
                         (repr(archs), modulename, versionname))
    basedir= module_basedir_string(modulename)
    ensure_dir(basedir, dry_run) # creates basedir if it doesn't exist
    dirname= module_dir_string(build_tag, modulename, versionname)
    if os.path.exists(dirname):
        raise ValueError("directory %s already exists" % dirname)

    create_source(db, modulename, versionname, dirname, verbose, dry_run)
    gen_RELEASE(db, builddb, build_tag, modulename, versionname,
                extra_defs,
                verbose, dry_run)
# pylint: enable=R0913

def add_modules(db, builddb, build_tag):
    """add modules to the builddb object.

    This function looks for compatible modules in all already existing builds.
    If possible, modules of existing builds are used.

    All modules specified by db are added with tag <build_tag> to the builddb.
    """
    for modulename in db.iter_modulenames():
        # get all versions, stable, testing and unstable, all archs,
        # must_exist=True:
        moduleversions= list(db.iter_versions(modulename, "unstable",
                                              None, True))
        if len(moduleversions)!=1:
            raise ValueError("more than one version for %s" % modulename)
        versionname= moduleversions[0]

        compatible_build= builddb_match(db, builddb, modulename,
                                        versionname)
        if compatible_build is None:
            # no existing build of the module was found, we have to build the
            # module ourselbves:
            build_tag_used= build_tag
        else:
            # a compatible existing build of the module was found:
            build_tag_used= compatible_build

        builddb.add_module(build_tag, build_tag_used, modulename, versionname)

# pylint: disable=R0913
#                          Too many arguments

def create_modules(partialdb, builddb, build_tag, extra_lines,
                   archs,
                   verbose, dry_run):
    """create all modules.

    This function requires that the current working directory is the support
    directory!
    """
    # save a list of possibly created directories in a cleanup-structure. In
    # case the script exits with an exception, the created cleanup file can be
    # used to clean up the support directory.
    # Load the cleanup file in case other parts of the script have saved
    # someting there:
    cleanup_struc= loadcleanup(build_tag)
    module_list  = cleanup_struc.setdefault("modules", [])

    # add all modules specified by partialdb to builddb under tag build_tag:
    add_modules(partialdb, builddb, build_tag)

    for modulename in partialdb.iter_modulenames():
        versionname= builddb.module_version(build_tag, modulename)
        # do not re-create modules that are links:
        if builddb.module_link(build_tag, modulename):
            continue
        module_list.append({"modulename" : modulename,
                            "versionname": versionname})

    if not dry_run:
        savecleanup(build_tag, cleanup_struc)
    for module_dict in module_list:
        create_module(partialdb, builddb, build_tag,
                      module_dict["modulename"],
                      module_dict["versionname"],
                      extra_lines,
                      archs,
                      verbose, dry_run)

# pylint: enable=R0913

def create_makefile(partialdb, builddb, build_tag, verbose, dry_run):
    """generate a makefile.
    """
    # pylint: disable=R0914
    #                          Too many local variables
    # pylint: disable=R0912
    #                          Too many branches
    def wr(fh, st, verbose):
        """write to file."""
        if verbose:
            print st,
        if fh:
            fh.write(st)
    def has_makefile(path):
        """checks if there is a makefile in path."""
        fn= os.path.join(path,"Makefile")
        if os.path.exists(fn):
            return True
        fn= os.path.join(path,"makefile")
        if os.path.exists(fn):
            return True
        return False
    paths= {}
    for modulename, versionname in builddb.iter_modules(build_tag):
        if not builddb.module_link(build_tag, modulename):
            dir_= module_dir_string(build_tag,
                                    modulename,
                                    versionname)
            if not has_makefile(dir_):
                continue
            paths[(modulename, versionname)]= dir_
    filename= makefilename(build_tag)
    if not dry_run:
        cleanup_struc= loadcleanup(build_tag)
        cleanup_struc["makefile"]= filename
        savecleanup(build_tag, cleanup_struc)
    module_dirs= sorted(paths.values())
    stamps= [os.path.join(p,"stamp") for p in module_dirs]
    fh= None
    if not dry_run:
        fh= open(filename, "w")
    wr(fh, "all: %s\n\n" % (" ".join(stamps)), verbose)
    wr(fh, "clean:\n", verbose)
    for d in module_dirs:
        wr(fh, "\tmake -C %s clean\n" % d, verbose)
    for f in stamps:
        wr(fh, "\trm %s\n" % f, verbose)
    wr(fh, "\n", verbose)
    for spec, path in paths.items():
        (modulename, versionname)= spec
        own_stamp= os.path.join(path, "stamp")
        dep_stamps= []
        for dep_name in partialdb.iter_dependencies(modulename, versionname):
            if builddb.module_link(build_tag, dep_name):
                continue
            # get all depdendencies, even the ones marked "unstable":
            # archs==None:
            #   ignore architecture
            dep_versions= list(partialdb.iter_dependency_versions(modulename,
                                                           versionname,
                                                           dep_name,
                                                           "unstable",
                                                           None))
            if len(dep_versions)>1:
                raise AssertionError("unexpected: %s:%s %s\n" % \
                        (modulename,versionname,repr(dep_versions)))
            dep_version= dep_versions[0]
            # modules that have no makefile are not in the paths dictionary, do
            # treat these as dependencies:
            if not paths.has_key((dep_name,dep_version)):
                continue
            dep_path= module_dir_string(build_tag, dep_name, dep_versions[0])
            dep_stamps.append(os.path.join(dep_path,"stamp"))

        if dep_stamps:
            wr(fh, "\n%s: %s\n" % (own_stamp, " ".join(dep_stamps)), verbose)
    wr(fh, "\n%/stamp:\n", verbose)
    wr(fh, "\tmake -C $(@D)\n", verbose)
    wr(fh, "\ttouch $@\n", verbose)
    if not dry_run:
        fh.close()

def create_partialdb(db, builddb, buildtag):
    """create a partial database from a build.

    This function also ensures that each module has only one dependency version
    for each dependency module.
    """
    new= utils.Dependencies()
    for modulename, versionname in builddb.iter_modules(buildtag):
        new.import_module(db, modulename, versionname)
        for dep_module in new.iter_dependencies(modulename, versionname):
            # archs==None:
            #   ignore architecture
            # we have to ignore the architecture here since the Dependencies
            # object "new" is beeing built bit by bit. When we iterate over the
            # dependencies of a module the dependency modules are not yet part
            # of the Dependencies object, so we cannot know their architecture.
            dep_versions= list(new.iter_dependency_versions(modulename,
                                                            versionname,
                                                            dep_module,
                                                            "unstable",
                                                            None))
            wanted_version= builddb.module_version(buildtag, dep_module)
            for d in dep_versions:
                if d!=wanted_version:
                    new.del_dependency(modulename, versionname, dep_module, d)
    return new

def fullapprelease(build_path, build_tag, builddb, db, modules,
                   aliases, extra_lines):
    """create entries for an release file.
    """
    # pylint: disable=R0913
    #                          Too many arguments
    lines= ["SUPPORT=%s" % os.path.abspath(build_path)]
    if modules is None:
        modules= builddb.modules(build_tag).keys()

    basenames= {}
    mods= []
    for modulename in modules:
        tag= builddb.module_link(build_tag, modulename)
        if tag is None:
            tag= build_tag
        version= builddb.module_version(tag, modulename)
        basenames[(modulename, version)]= \
                   module_dir_string(tag, modulename, version)
        mods.append((modulename, version))

    mods= db.sortby_weight(db.sortby_dependency(sorted(mods), True))
    for (modulename, version) in mods:
        lines.append("%s=%s" % \
                (alias(aliases, modulename),
                 os.path.join("$(SUPPORT)", basenames[(modulename, version)])
                ))
    lines.extend(extra_lines)
    return "\n".join(lines)

# pylint: disable=R0913
#                          Too many arguments

def apprelease(build_path, build_tag, module_spec, builddb, db,
               archs, aliases, extra_lines):
    """create entries for an release file.
    """
    build_modules= builddb.modules(build_tag)
    module_dict= {}
    for m in module_spec:
        (modulename,modulespec)= utils.scan_module_arch_spec(m, archs)
        v= build_modules.get(modulename)
        if v is None:
            sys.exit("error: module %s not found in build %s" % \
                     (modulename, build_tag))
        if not utils.compare_versions_flag(modulespec.get("version_flag"),
                                           v, modulespec.get("version")):
            sys.exit(("error: no module matching %s "+ \
                      "found in build %s") % (m, build_tag))
        module_dict[modulename]= v
    get_dependencies(module_dict, db, builddb, build_tag)
    return fullapprelease(build_path, build_tag, builddb, db,
                          module_dict.keys(), aliases, extra_lines)

# pylint: enable=R0913

def script_shortname():
    """return the name of this script without a path component."""
    return os.path.basename(sys.argv[0])

# pylint: disable=R0912
#                          Too many branches
# pylint: disable=R0911
#                          Too many return statements
# pylint: disable=R0915
#                          Too many statements

def process(options, commands):
    """do all the work.
    """
    if options.nolock:
        utils.use_lockfile= False
    if not commands:
        sys.exit("command missing")
    if commands[0] not in KNOWN_COMMANDS:
        sys.exit("unknown command: %s" % commands[0])

    if not options.extra:
        options.extra= []

    if commands[0]=="edit":
        if options.readonly:
            sys.exit("--readonly forbids editing a database file")
        if len(commands)!=2:
            sys.exit("exactly one filename must follow \"edit\"")
        utils.edit_with_lock(commands[1], options.verbose, options.dry_run)
        return

    if commands[0]=="list":
        if len(commands)>1:
            sys.exit("error: extra arguments following \"list\"")
        if not options.builddb:
            sys.exit("--builddb is mandatory")
        builddb= utils.Builddb.from_json_file(options.builddb)
        for buildtag in builddb.iter_builds():
            print buildtag
        return

    if commands[0]=="show":
        if len(commands)>2:
            sys.exit("error: extra arguments following \"show\"")
        if len(commands)<=1:
            sys.exit("error: buildtag missing")
        if not options.builddb:
            sys.exit("--builddb is mandatory")
        buildtag= commands[1]
        builddb= utils.Builddb.from_json_file(options.builddb)
        if not builddb.has_build_tag(buildtag):
            sys.exit("error, buildtag \"%s\" not found" % buildtag)
        new_builddb= utils.Builddb()
        new_builddb.add_build(builddb, buildtag)
        new_builddb.json_print()
        return

    if commands[0]=="state":
        if options.readonly:
            sys.exit("--readonly forbids changing the state of a build")
        if len(commands)<=1:
            sys.exit("error: buildtag missing")
        buildtag= commands[1]
        if len(commands)>3:
            sys.exit("error: extra arguments following \"state\"")
        if len(commands)<=2:
            new_state= None
        else:
            new_state= utils.Builddb.guess_state(commands[2].strip())
        if new_state:
            if not options.db:
                sys.exit("--db is mandatory")
        if not options.builddb:
            sys.exit("--builddb is mandatory")
        if new_state:
            db= utils.Dependencies.from_json_file(options.db,
                    keep_locked= not options.dry_run)
        else:
            db= None
        builddb= utils.Builddb.from_json_file(options.builddb,
                keep_locked= not options.dry_run)
        if not builddb.has_build_tag(buildtag):
            # db and builddb __del__ method should remove lockfiles
            sys.exit("error, buildtag \"%s\" not found" % buildtag)
        if not new_state:
            print "%-20s : %s" % (buildtag, builddb.state(buildtag))
        else:
            try:
                builddb.change_state(buildtag, new_state)
            except ValueError, e:
                # db and builddb __del__ method should remove lockfiles
                sys.exit(str(e))
            builddb.json_save(options.builddb,
                              options.verbose, options.dry_run)
            # ^^^ does also unlock the file
            partialdb= create_partialdb(db, builddb, buildtag)
            db.merge(partialdb, new_state)
            db.json_save(options.db, options.verbose, options.dry_run)
            # ^^^ does also unlock the file
        return

    if commands[0]=="delete":
        if options.readonly:
            sys.exit("--readonly forbids deleting a support")
        if len(commands)>2:
            sys.exit("error: extra arguments following \"delete\"")
        if len(commands)<=1:
            sys.exit("error: buildtag missing")
        if not options.builddb:
            sys.exit("--builddb is mandatory")
        buildtag= commands[1]
        builddb= utils.Builddb.from_json_file(options.builddb)
        if not builddb.has_build_tag(buildtag):
            sys.exit("error, buildtag \"%s\" not found" % buildtag)
        try:
            delete_modules(builddb, buildtag,
                           options.verbose, options.dry_run)
        except ValueError, e:
            sys.exit(str(e))
        builddb.json_save(options.builddb,
                          options.verbose, options.dry_run)
        return

    if commands[0]=="cleanup":
        if options.readonly:
            sys.exit("--readonly forbids cleaning up")
        if len(commands)>2:
            sys.exit("error: extra arguments following \"cleanup\"")
        if len(commands)<=1:
            sys.exit("error: buildtag missing")
        buildtag= commands[1]
        cleanup_modules(buildtag, options.verbose, options.dry_run)
        return

    if commands[0]=="new":
        if options.readonly:
            sys.exit("--readonly forbids creating a new build")
        if len(commands)>2:
            sys.exit("error: extra arguments following \"new\"")
        if len(commands)<=1:
            sys.exit("error: buildtag missing")
        if not options.db:
            sys.exit("--db is mandatory")
        if not options.partialdb:
            sys.exit("--partialdb is mandatory")
        if not options.builddb:
            sys.exit("--builddb is mandatory")
        buildtag= commands[1]
        db= utils.Dependencies.from_json_file(options.db,
                    keep_locked= not options.dry_run)
        partialdb= utils.Dependencies.from_json_file(options.partialdb)
        if not os.path.exists(options.builddb):
            builddb= utils.Builddb()
        else:
            builddb= utils.Builddb.from_json_file(options.builddb,
                        keep_locked= not options.dry_run)
        if builddb.has_build_tag(buildtag):
            # db and builddb __del__ method should remove lockfiles
            sys.exit("error, buildtag \"%s\" already taken" % buildtag)
        # create a new build in builddb, initial state is "unstable":
        builddb.new_build(buildtag, "unstable")
        if options.supportdir:
            os.chdir(options.supportdir)
        # modifies builddb:
        create_modules(partialdb, builddb, buildtag,
                       options.extra,
                       options.arch,
                       options.verbose, options.dry_run)
        create_makefile(partialdb, builddb, buildtag,
                        options.verbose, options.dry_run)
        db.merge(partialdb, "unstable")
        builddb.json_save(options.builddb, options.verbose, options.dry_run)
        # ^^^ does also unlock the file
        db.json_save(options.db, options.verbose, options.dry_run)
        # ^^^ does also unlock the file
        rmcleanup(buildtag)
        return
    if commands[0]=="partialdb":
        if len(commands)>2:
            sys.exit("error: extra arguments following \"partialdb\"")
        if len(commands)<=1:
            sys.exit("error: buildtag missing")
        if not options.db:
            sys.exit("--db is mandatory")
        if not options.builddb:
            sys.exit("--builddb is mandatory")
        buildtag= commands[1]
        db= utils.Dependencies.from_json_file(options.db)
        builddb= utils.Builddb.from_json_file(options.builddb)
        new_db= create_partialdb(db, builddb, buildtag)
        new_db.json_print()
        return
    if commands[0]=="find":
        if len(commands)>=2:
            modulespecs= commands[1:]
        else:
            # no modulespecs after the command
            modulespecs= options.module
            if not modulespecs:
                sys.exit("error: module specs missing")

        if not options.builddb:
            sys.exit("--builddb is mandatory")
        if not options.db:
            sys.exit("--db is mandatory")
        db= utils.Dependencies.from_json_file(options.db)
        builddb= utils.Builddb.from_json_file(options.builddb)
        new_builddb= builddb.filter_by_specs(modulespecs,
                                             options.arch,
                                             db)
        if not options.brief:
            new_builddb.json_print()
        else:
            if new_builddb.is_empty():
                print "no matching buildtrees found"
            else:
                print "matches:"
                d= {}
                for b in new_builddb.iter_builds():
                    d[b]= new_builddb.modules(b)
                utils.json_dump(d)
        return
    if commands[0]=="useall":
        if len(commands)>2:
            sys.exit("error: extra arguments following \"useall\"")
        if len(commands)<=1:
            sys.exit("error: buildtag missing")
        if not options.db:
            sys.exit("--db is mandatory")
        buildtag= commands[1]
        builddb= utils.Builddb.from_json_file(options.builddb)
        db= utils.Dependencies.from_json_file(options.db)
        print fullapprelease(options.supportdir \
                                 if options.supportdir else ".",
                             buildtag,
                             builddb,
                             db,
                             None,
                             scan_aliases(options.alias),
                             options.extra)
        return

    if commands[0]=="use":
        if len(commands)<=1:
            sys.exit("error: buildtag missing")
        if not options.db:
            sys.exit("--db is mandatory")
        buildtag= commands[1]

        if len(commands)>=3:
            modulespecs= commands[2:]
        else:
            # no modulespecs after the command
            modulespecs= options.module
            if not modulespecs:
                sys.exit("error: module specs missing")

        db= utils.Dependencies.from_json_file(options.db)
        builddb= utils.Builddb.from_json_file(options.builddb)
        print apprelease(options.supportdir \
                             if options.supportdir else ".",
                         buildtag,
                         modulespecs,
                         builddb,
                         db,
                         options.arch,
                         scan_aliases(options.alias),
                         options.extra)
        return

# pylint: enable=R0912
# pylint: enable=R0911
# pylint: enable=R0915

def print_summary():
    """print a short summary of the scripts function."""
    print "%-20s: a tool for managing support EPICS trees \n" % \
          script_shortname()

def _test():
    """does a self-test of some functions defined here."""
    print "performing self test..."
    import doctest
    doctest.testmod()
    print "done!"

usage = """usage: %prog [options] command
where command is:
  edit [FILE]
          Start the editor specified by the environment variable "VISUAL" or
          "EDITOR" with that file. This command first aquires a file-lock on
          the file that is only released when the editor program is terminated.
          If you want to edit a DB or BUILDDB file directly, you should always
          do this with this command. The file locking prevents other users to
          use the file at the same time you modify it.
  new [BUILDTAG]
          This command creates a new build. It must be followed by a buildtag.
          Note that options "--db", --partialdb" and "--builddb" are mandatory
          for this command.
  partialdb [BUILDTAG]
          This command recreates a partialdb from a complete DB and a build.
          The partialdb is printed on the console.
  find [MODULESPECS]
          This command is used to find matching builds for a given list of
          modulespecs. It prints a list of buildtags of matching builds on the
          console.  Note that the versions in modulespecs may be *unspecified*,
          *specified exactly* or *specifed by relation*.
  useall [BUILDTAG]
          This command creates a RELEASE file for an application. The command
          must be followed by buildtag. The release file is created that it
          includes *all* modules of the build.
  use [BUILDTAG] [MODULES]
          This command creates a RELEASE file for an application. The command
          must be followed by a buildtag and a list of modulespecs. The RELEASE
          created includes only the modules that are specified. For this
          command the DB file must be specified with the "--db" option.
  list    
          This command lists the names of all builds.
  show [BUILDTAG]
          This command shows the data of a build. It must be followed by a
          buildtag. 
  state [BUILDTAG] {NEW STATE}
          This command is used to show or change the state of a build. If must
          be followed by a buildtag. If there is no new state given, it just
          shows the current state of the build. Otherwise the state of the
          build is changed to the given value. 
  delete [BUILDTAG]
          If no other build depends on the build specified by the buildtag, the
          directories of the build are removed and it's entry in the builddb is
          deleted.
  cleanup [BUILDTAG]
          This command removes the remains of a failed build. If the command
          "new" is interrupted or stopped by an exception in the program, the
          build may be in an incomplete state. In this case you can use the
          "cleanup" command to remove the directories of the failed build.
"""

def main():
    """The main function.

    parse the command-line options and perform the command
    """
    # command-line options and command-line help:

    parser = OptionParser(usage=usage,
                          version="%%prog %s" % my_version,
                          description="This program manages EPICS support trees"
                         )

    parser.add_option("--summary",
                      action="store_true",
                      help="Print a summary of the function of the program.",
                      )
    parser.add_option("--test",
                      action="store_true",
                      help="Perform simple self-test.",
                      )
    parser.add_option("-c", "--config",
                      action="store",
                      type="string",
                      help="Load options from config file FILE, "
                           "default: %s." % CONFIG_NAME,
                      metavar="FILE"
                      )
    parser.add_option("--make-config",
                      action="store",
                      type="string",
                      help="Create a new config file FILE from the given "
                           "options. If the filename is '-' dump "
                           "to the console, if it is an empty string, "
                           "rewrite the config file that was read before.",
                      metavar="FILE"
                      )
    parser.add_option("--db",
                      action="store",
                      type="string",
                      help="Define the name of the DBFILE. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="DBFILE"
                      )
    parser.add_option("-P", "--partialdb",
                      action="store",
                      type="string",
                      help="Define the name of the PARTIALDBFILE.",
                      metavar="PARTIALDBFILE"
                      )
    parser.add_option("--builddb",
                      action="store",
                      type="string",
                      help="Specify the BUILDDATABASE. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="BUILDDATABASE"
                      )
    parser.add_option("--supportdir",
                      action="store",
                      type="string",
                      help="Specify the SUPPORTDIRECTORY. If this option "
                           "is not given take the current working "
                           "directory as SUPPORTDIRECTORY. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="SUPPORTDIRECTORY"
                      )
    parser.add_option("-x", "--extra",
                      action="append",
                      type="string",
                      help="Extra lines that are added to the RELEASE "
                           "file. A LINE may be an arbitrary string or "
                           "definition. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="LINE"
                      )
    parser.add_option("-a", "--alias",
                      action="append",
                      type="string",
                      help="Define an ALIAS for the commands 'use' "
                           "and 'useall'. An ALIAS must have the "
                           "form FROM:TO. A module named 'FROM' is then "
                           "put to the generated RELEASE file as 'TO'. "
                           "You can specify more than one of these by "
                           "repeating this option or by joining values in "
                           "a single string separated by spaces. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="LINE"
                      )
    parser.add_option("--arch",
                      action="append",
                      help="Define the name of a TARGETARCHITECTURE. You "
                           "can specify more than one target architecture."
                           "You can specify more than one of these by "
                           "repeating this option or by joining values in "
                           "a single string separated by spaces. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="TARGETARCHITECTURE"
                      )
    parser.add_option("-m", "--module",
                      action="append",
                      help="Define a MODULESPEC. A MODULESPEC has the form "
                           "modulename, modulename:version, "
                           "modulename:-version or modulename:+version. If "
                           "you specify modules with this option you don't "
                           "have to put MODULESPECs after commands like "
                           "'find' or 'use'. "
                           "You can specify more than one of these by "
                           "repeating this option or by joining values in "
                           "a single string separated by spaces. "
                           "This option value is stored in the CONFIGFILE.",
                      metavar="MODULESPEC"
                      )
    parser.add_option("-b", "--brief",
                      action="store_true",
                      help="Do a more brief output for some commands.",
                      )
    parser.add_option("--readonly",
                      action="store_true",
                      help="Do not allow modifying the database files or "
                           "the support directory. "
                           "This option value is stored in the CONFIGFILE.",
                      )
    parser.add_option("--nolock",
                      action="store_true",
                      help="Do not use file locking."
                      )
    parser.add_option("-p", "--progress",
                      action="store_true",
                      help="Show progress on stderr. "
                           "This option value is stored in the CONFIGFILE.",
                      )
    parser.add_option("-v", "--verbose",
                      action="store_true",
                      help="Show command calls. "
                           "This option value is stored in the CONFIGFILE.",
                      )
    parser.add_option("-n", "--dry-run",
                      action="store_true",
                      help="Just show what the program would do.",
                      )

    # x= sys.argv
    (options, args) = parser.parse_args()
    # options: the options-object
    # args: list of left-over args

    # join some of the list options:
    options.arch  = utils.opt_join(options.arch, do_sort= True)
    options.alias = utils.opt_join(options.alias, do_sort= True)
    options.module= utils.opt_join(options.module)

    config= utils.ConfigFile(( "arch", "alias", "builddb", "db", "extra",
                               "module",
                               "progress",
                               "readonly",
                               "supportdir",
                               "verbose",),
                               CONFIG_NAME)

    if options.summary:
        print_summary()
        sys.exit(0)

    if options.test:
        _test()
        sys.exit(0)

    config.load_file(options.config)
    # Note: options that are "None" are not changed in the config object:
    config.update_from_options(options)
    config.fill_options(options, overwrite= False)

    if options.make_config is not None:
        config.save_file(options.make_config)
        sys.exit(0)

    # we could pass "args" as an additional parameter to process here if it
    # would be needed to process remaining command line arguments.
    process(options, args)
    sys.exit(0)

if __name__ == "__main__":
    main()



